## 📋 질문 목록
1. [SQL과 NoSQL 데이터베이스의 차이점](#1-sql과-nosql-데이터베이스의-차이점은-무엇인가요-어떤-상황에-어떤-데이터베이스를-선택하는-게-좋을까요)
2. [재고 동시성 문제 해결 방법](#2-재고-동시성-문제가-발생했을-때-어떤-해결-방법을-선택하실-건가요)
3. [데이터베이스 트랜잭션(Transaction)이란 무엇인가요?](#3-데이터베이스-트랜잭션transaction이란-무엇인가요-그리고-트랜잭션이-보장해야-할-4가지-특징-acid에-대해서도-설명해주세요)
4. [캐시(Cache)란 무엇이고, 왜 사용하나요?](#4-캐시cache란-무엇이고-왜-사용하나요)
5. [데이터베이스 샤딩(Sharding)이란 무엇이고, 언제 사용하나요?](#5-데이터베이스-샤딩sharding이란-무엇이고-언제-사용하나요)
6. [N+1 문제란 무엇이고, 어떻게 해결할 수 있나요?](#6-n1-문제란-무엇이고-어떻게-해결할-수-있나요)


## 1. SQL과 NoSQL 데이터베이스의 차이점은 무엇인가요? 어떤 상황에 어떤 데이터베이스를 선택하는 게 좋을까요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.16)

**답변**

SQL은 데이터 간의 **관계를 중심**으로 설계된 관계형 데이터베이스로, **정해진 스키마 구조**를 따라 테이블에 데이터를 저장합니다. 여러 테이블 간의 관계를 외래키로 연결하고 JOIN을 통해 데이터를 조회합니다.

NoSQL은 관계보다는 **데이터 자체를 중심**으로 설계된 비관계형 데이터베이스로, **유연한 구조**를 가지고 있어 스키마 변경이 자유롭습니다. 문서, 키-값, 그래프 등 다양한 형태로 데이터를 저장합니다.

**선택 기준**
- SQL: 데이터 간 관계가 복잡하고 정형화된 구조가 필요할 때, 데이터 정합성과 트랜잭션이 중요한 금융/회계 시스템
- NoSQL: 관계보다 빠른 읽기/쓰기가 중요하고, 구조 변경이 잦을 때, 대용량 비정형 데이터를 다루는 경우


## **예상 꼬리질문**

**Q1. 정형과 비정형 데이터는 어떠한 차이가 있는걸까요?**

A. 정형 데이터는 미리 정의된 구조(스키마)에 따라 행과 열로 정리된 데이터입니다. 예를 들어 사용자 테이블에 id, name, email 같은 고정된 필드가 있는 경우죠. 

비정형 데이터는 정해진 구조 없이 자유로운 형태로 저장되는 데이터입니다. 예를 들어 SNS 게시물처럼 어떤 글은 텍스트만 있고, 어떤 글은 이미지와 태그가 추가되는 식으로 각 데이터의 구조가 다를 수 있습니다. 반정형 데이터(JSON, XML)도 있는데, 이는 일정한 구조는 있지만 스키마만큼 엄격하지는 않습니다.


**Q2. NoSQL이 SQL보다 속도 측면이나 데이터를 유연하게 저장할 수 있다는 점에서 더욱 장점이 많은 것 같은데, 실제로는 RDBMS가 많이 사용되는 이유는 무엇일까요?**

A. 가장 큰 이유는 데이터의 안정성과 무결성 검증이 편하기 때문입니다.
SQL은 스키마를 통해 데이터 타입과 제약조건을 강제하고, ACID 트랜잭션으로 데이터 정합성을 보장합니다. 예를 들어 계좌이체처럼 "A에서 돈을 빼고 B에 넣는" 작업이 반드시 함께 성공하거나 함께 실패해야 하는 경우, SQL의 트랜잭션이 이를 자동으로 보장해줍니다.
또한 외래키 제약조건으로 관계의 무결성을 데이터베이스 레벨에서 검증할 수 있어, 잘못된 데이터가 들어가는 것을 원천적으로 막을 수 있습니다.
금융, 전자상거래, 의료 시스템처럼 데이터 오류가 치명적인 분야에서는 이러한 안정성이 속도나 유연성보다 훨씬 중요하기 때문에 RDBMS를 선호합니다.

---

## 2. 재고 동시성 문제가 발생했을 때 어떤 해결 방법을 선택하실 건가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.22)

**답변**
**낙관적 락**을 우선적으로 고려할 것 같습니다.

재고 동시성 문제는 여러 사용자가 동시에 같은 상품을 구매할 때 발생하는데, 대부분의 이커머스 환경에서는 실제로 충돌이 자주 발생하지 않기 때문입니다. 낙관적 락은 버전 필드나 타임스탬프를 이용해 데이터 수정 시점에만 충돌을 체크하므로, 읽기 작업이 많은 환경에서 성능상 유리합니다.

구현 방식:
1. 상품 테이블에 version 컬럼 추가
2. UPDATE 시 WHERE 절에 version 조건 추가
3. 업데이트된 row가 0개면 재시도 또는 실패 처리

만약 충돌이 매우 빈번한 상황(예: 한정 수량 이벤트)이라면 비관적 락이나 Redis를 이용한 분산 락을 고려하겠지만, 일반적인 상황에서는 낙관적 락이 시스템 성능과 사용자 경험 측면에서 균형잡힌 선택이라고 생각합니다.

## **예상 꼬리질문**

**Q1. 낙관적 락과 비관적 락의 차이점**

A. 낙관적 락은 "충돌이 거의 일어나지 않을 것"이라고 낙관적으로 가정하는 방식입니다. 데이터를 읽을 때는 락을 걸지 않고, 수정하는 시점에 다른 트랜잭션이 데이터를 변경했는지 확인합니다. JPA의 @Version 어노테이션처럼 버전 번호를 이용해 구현합니다.

비관적 락은 "충돌이 자주 일어날 것"이라고 비관적으로 가정하고, 데이터를 읽는 시점부터 락을 겁니다. SELECT ... FOR UPDATE 구문을 사용해 다른 트랜잭션이 해당 row에 접근하지 못하도록 막습니다. 충돌은 확실히 방지하지만, 락 대기 시간으로 인한 성능 저하와 데드락 위험이 있습니다.

**Q2. MVCC란 무엇인가요? 이것과 락은 어떤 관계가 있나요?**

A. MVCC(Multi-Version Concurrency Control)는 데이터베이스가 동시성을 처리하는 기본 메커니즘입니다. 각 트랜잭션이 데이터의 특정 시점 버전(스냅샷)을 보도록 해서, 읽기 작업이 쓰기 작업을 블로킹하지 않도록 합니다.

예를 들어 MySQL InnoDB에서는 Undo Log를 이용해 여러 버전의 데이터를 관리합니다. 트랜잭션 A가 데이터를 수정 중이어도, 트랜잭션 B는 이전 버전의 데이터를 읽을 수 있어 읽기 성능이 향상됩니다.

하지만 MVCC만으로는 두 트랜잭션이 동시에 같은 데이터를 수정해서 한 쪽 변경사항이 사라지는 문제(Lost Update 문제)를 완전히 해결할 수 없어서, 재고 같은 중요한 데이터는 추가적인 락 메커니즘이 필요합니다.

**Q3. 실무에서 Redis를 이용한 분산 락은 언제 사용하나요?**

A. MSA 환경에서 여러 서버 인스턴스가 동시에 같은 자원에 접근할 때 사용합니다. DB 레벨의 락은 단일 데이터베이스 내에서만 동작하지만, 분산 락은 여러 애플리케이션 서버 간의 동시성을 제어할 수 있습니다.

예를 들어 선착순 이벤트에서 Redis의 SETNX 명령어와 TTL을 조합해 락을 구현합니다. 다만 Redis 장애 시 전체 시스템이 영향받을 수 있어 고가용성 구성이 필수입니다.

---
## 3. 데이터베이스 트랜잭션(Transaction)이란 무엇인가요? 그리고 트랜잭션이 보장해야 할 4가지 특징, ACID에 대해서도 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.28)

**답변**
트랜잭션은 데이터베이스에서 **하나의 논리적인 작업 단위**로 실행되는 일련의 연산들입니다. 여러 개의 데이터 조작(INSERT, UPDATE, DELETE 등)을 묶어서, 전부 성공하거나(Commit) 전부 실패하도록(Rollback) 보장합니다.

예를 들어 계좌이체 상황을 생각해보면, "A 계좌에서 10만원 차감"과 "B 계좌에 10만원 추가"라는 두 작업이 하나의 트랜잭션으로 처리되어야 합니다. 만약 중간에 시스템 장애가 발생하더라도, 두 작업이 모두 성공하거나 모두 취소되어 데이터 불일치를 방지할 수 있습니다.

**ACID 특성**

트랜잭션이 안전하게 처리되기 위해 반드시 보장해야 하는 4가지 특성입니다.

**1. Atomicity (원자성)**
- 트랜잭션 내의 모든 연산이 전부 실행되거나, 전혀 실행되지 않아야 합니다.
- 중간에 실패하면 이미 실행된 작업도 모두 롤백되어 원래 상태로 돌아갑니다.
- 예시: 송금 중 B 계좌 입금이 실패하면, A 계좌 출금도 취소됩니다.

**2. Consistency (일관성)**
- 트랜잭션이 성공적으로 완료되면, 데이터베이스는 일관된 상태를 유지해야 합니다.
- 모든 제약조건(NOT NULL, UNIQUE, 외래키 등)을 만족해야 합니다.
- 예시: 잔액이 음수가 될 수 없다는 제약조건이 있다면, 트랜잭션 후에도 이를 만족해야 합니다.

**3. Isolation (격리성)**
- 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션은 다른 트랜잭션의 영향을 받지 않고 독립적으로 실행되어야 합니다.
- 동시성 제어를 통해 구현되며, 격리 수준(Isolation Level)을 조정할 수 있습니다.
- 예시: A와 B가 동시에 같은 상품을 주문할 때, 재고가 1개라면 한 명만 구매할 수 있어야 합니다.

**4. Durability (지속성)**
- 트랜잭션이 성공적으로 완료(Commit)되면, 그 결과는 시스템 장애가 발생하더라도 영구적으로 저장되어야 합니다.
- 데이터베이스는 로그를 활용하여 장애 발생 시 복구할 수 있습니다.
- 예시: 결제 완료 후 서버가 다운되더라도, 재시작 시 결제 내역이 남아있어야 합니다.


## **예상 꼬리질문**

**Q1. 트랜잭션의 Commit과 Rollback은 구체적으로 어떻게 동작하나요?**

A. Commit은 트랜잭션의 모든 작업이 성공적으로 완료되었을 때 변경사항을 데이터베이스에 영구적으로 반영하는 것입니다. 
Commit이 실행되면 해당 트랜잭션이 수행한 모든 변경사항이 확정되고, 다른 트랜잭션에서도 조회할 수 있게 됩니다.

Rollback은 트랜잭션 중간에 오류가 발생하거나 명시적으로 취소할 때, 해당 트랜잭션이 수행한 모든 작업을 취소하고 트랜잭션 시작 이전 상태로 되돌리는 것입니다. 
데이터베이스는 로그를 활용하여 이전 상태를 복원합니다.


**Q2. 트랜잭션을 사용하면 성능이 저하되지 않나요? 언제 트랜잭션을 사용해야 할까요?**

A. 맞습니다. 트랜잭션은 잠금(Lock)과 로깅 오버헤드로 인해 성능이 저하될 수 있습니다. 하지만 데이터 정합성이 중요한 경우에는 반드시 사용해야 합니다.

트랜잭션을 사용해야 하는 경우:
- 금융 거래처럼 데이터 일관성이 절대적으로 중요한 경우
- 여러 테이블에 걸친 연관된 데이터를 수정할 때
- 동시에 여러 사용자가 같은 데이터를 수정할 가능성이 있을 때

트랜잭션이 불필요한 경우:
- 단순 조회(SELECT)만 하는 경우
- 로그 기록처럼 정합성보다 처리량이 중요한 경우
- 실시간 분석처럼 약간의 데이터 불일치가 허용되는 경우

트랜잭션 범위는 가능한 한 작게 유지하고, 필요한 작업만 포함시켜 성능 저하를 최소화하는 것이 좋습니다.

---

## 4. 캐시(Cache)란 무엇이고, 왜 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.13)

**답변**

캐시는 **자주 사용되는 데이터를 임시로 빠른 저장소에 보관**해두는 기술입니다. 데이터베이스에서 매번 데이터를 조회하는 대신, 한 번 조회한 결과를 메모리에 저장해두고 재사용하는 방식입니다.

데이터베이스는 디스크에 데이터를 저장하고, 디스크 I/O는 매우 느립니다. 반면 캐시는 RAM(메모리)에 데이터를 저장하는데, RAM은 디스크보다 수백 배 빠릅니다. 

예를 들어 디스크에서 데이터를 읽는데 10ms가 걸린다면, 메모리에서는 0.1ms면 충분합니다. 게다가 데이터베이스는 복잡한 쿼리를 처리하고, 여러 테이블을 JOIN하고, 인덱스를 탐색하는 등 추가 작업이 필요하지만, 캐시는 이미 계산된 결과를 Key-Value 형태로 바로 가져오기 때문에 훨씬 단순하고 빠릅니다.

**캐시 사용이 효과적인 상황**

1. **읽기가 많고 변경이 적은 데이터**: 상품 정보, 카테고리 목록, 설정 값처럼 자주 조회되지만 거의 변경되지 않는 데이터

2. **계산 비용이 높은 데이터**: 복잡한 통계나 집계 결과, 여러 테이블을 JOIN한 결과처럼 계산하는 데 시간이 오래 걸리는 데이터

3. **동일한 요청이 반복되는 경우**: 인기 게시글, 베스트 상품처럼 많은 사용자가 같은 데이터를 반복해서 조회하는 경우

4. **실시간성이 조금 떨어져도 되는 데이터**: 조회수, 좋아요 수처럼 몇 초~몇 분 정도의 지연이 허용되는 데이터

대표적인 캐시 시스템으로는 Redis, Memcached가 있으며, 애플리케이션 내부에서 사용하는 로컬 캐시(Caffeine, Ehcache)도 많이 활용됩니다.


## **예상 꼬리질문**

**Q1. 캐시를 사용할 때 주의해야 할 점은 무엇인가요?**

A. 가장 큰 문제는 **캐시와 데이터베이스 간의 불일치**입니다. 데이터베이스의 데이터가 변경되었는데 캐시가 업데이트되지 않으면, 사용자는 오래된 데이터를 보게 됩니다.

이를 해결하기 위한 전략들:

1. **TTL 설정**: 캐시에 유효 기간을 설정해서 일정 시간이 지나면 자동으로 삭제되도록 합니다. 예를 들어 상품 정보는 10분 TTL을 설정해서, 10분마다 최신 데이터를 다시 가져옵니다.

2. **캐시 무효화**: 데이터가 변경될 때 해당 캐시를 직접 삭제하거나 업데이트합니다. 상품 가격을 수정하면 해당 상품의 캐시를 즉시 삭제하는 식입니다.

---

## 5. 데이터베이스 샤딩(Sharding)이란 무엇이고, 언제 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.24)

**답변**

샤딩(Sharding)은 대규모 데이터를 여러 데이터베이스 서버에 나눠서 저장하는 수평 파티셔닝 기법입니다. 데이터를 **샤드(Shard)**라고 부르는 작은 단위로 쪼개서 각각 다른 서버에 분산 저장합니다.

단일 서버는 저장 용량과 처리 성능에 한계가 있기 때문에, 데이터가 계속 늘어나면 결국 병목이 발생합니다. 샤딩은 이런 한계를 극복하기 위해 데이터를 물리적으로 여러 서버로 분산시킵니다.

**예시**
사용자 데이터를 지역별로 샤딩하는 경우:
- 샤드 1 (아시아 서버): 아시아 지역 사용자 데이터
- 샤드 2 (유럽 서버): 유럽 지역 사용자 데이터  
- 샤드 3 (미국 서버): 미국 지역 사용자 데이터

각 서버가 전체 데이터의 일부만 처리하기 때문에 부하가 분산되고, 전체적인 처리 성능이 향상됩니다.

**언제 사용하나요?**
- 단일 데이터베이스의 저장 용량이 한계에 도달했을 때
- 읽기/쓰기 요청이 너무 많아서 단일 서버로 감당이 안 될 때
- 수직 확장(Scale-up)으로는 비용이 너무 높거나 물리적 한계에 도달했을 때
- 데이터가 지리적으로 분산되어 있어서 지역별로 나누면 응답 속도를 개선할 수 있을 때


## **예상 꼬리질문**

**Q1. 샤딩의 단점이나 문제점은 무엇인가요?**

A. 샤딩을 도입하면 시스템이 복잡해지고 여러 문제가 발생할 수 있습니다.

- **조인 연산의 어려움**: 서로 다른 샤드에 있는 데이터를 조인하려면 여러 서버에 쿼리를 날려서 애플리케이션 레벨에서 합쳐야 하므로 성능이 떨어집니다.
- **데이터 재분배의 어려움**: 샤드를 추가하거나 제거할 때 기존 데이터를 재분배해야 하는데, 이 과정이 매우 복잡하고 서비스 중단이 발생할 수 있습니다.
- **샤드 불균형 문제**: 특정 샤드에만 데이터가 몰리면(핫스팟) 그 샤드가 병목이 되어 샤딩의 효과가 떨어집니다.
- **트랜잭션 관리의 복잡성**: 여러 샤드에 걸친 트랜잭션을 처리하기 어렵고, 분산 트랜잭션이 필요한 경우 성능과 복잡도가 크게 증가합니다.

따라서 샤딩은 정말 필요할 때만 신중하게 도입해야 합니다.


**Q2. 샤딩 전략에는 어떤 것들이 있나요?**

A. 데이터를 어떻게 나눌지에 따라 여러 전략이 있습니다.

**범위 기반 샤딩 (Range-based Sharding)**
- 데이터를 특정 범위로 나눕니다.
- 예: 사용자 ID 1~1000은 샤드1, 1001~2000은 샤드2
- 장점: 구현이 간단하고 범위 쿼리에 유리
- 단점: 데이터가 특정 샤드에 몰릴 수 있음

**해시 기반 샤딩 (Hash-based Sharding)**
- 샤딩 키를 해시 함수에 넣어서 나온 값으로 샤드를 결정합니다.
- 예: hash(user_id) % 샤드 개수
- 장점: 데이터가 균등하게 분산됨
- 단점: 범위 쿼리가 어렵고, 샤드 추가/제거 시 많은 데이터 재배치 필요

**지리 기반 샤딩 (Geographic Sharding)**
- 지역별로 데이터를 나눕니다.
- 예: 한국 사용자는 한국 서버, 미국 사용자는 미국 서버
- 장점: 지역 사용자에게 낮은 지연시간 제공
- 단점: 지역별 데이터 불균형 가능

**디렉토리 기반 샤딩 (Directory-based Sharding)**
- 별도의 룩업 테이블을 두고 어떤 데이터가 어느 샤드에 있는지 관리합니다.
- 장점: 유연하게 샤드를 변경 가능
- 단점: 룩업 테이블이 병목이 될 수 있음


**Q3. 샤딩과 파티셔닝의 차이는 무엇인가요?**

A. 파티셔닝은 데이터를 나누는 일반적인 개념이고, 샤딩은 파티셔닝의 특수한 형태입니다.

**파티셔닝**은 데이터를 논리적 또는 물리적으로 나누는 것을 의미하며, 주로 **단일 데이터베이스 내에서** 테이블을 여러 파티션으로 나눕니다. 예를 들어 날짜별로 테이블을 파티션으로 나눠서 2024년 데이터는 파티션1, 2025년 데이터는 파티션2에 저장하는 식이에요.

**샤딩**은 데이터를 **여러 서버(데이터베이스 인스턴스)에 분산**시키는 수평 파티셔닝입니다. 각 샤드는 독립적인 데이터베이스 서버에 위치합니다.

- 파티셔닝 = 한 서버 안에서 데이터를 나눔
- 샤딩 = 여러 서버로 데이터를 나눔

---

## 6. N+1 문제란 무엇이고, 어떻게 해결할 수 있나요?

**답변**

N+1 문제는 **ORM을 사용할 때 발생하는 성능 문제**로, 연관된 데이터를 조회할 때 예상보다 훨씬 많은 쿼리가 실행되는 현상입니다.

예를 들어 콘서트 10개를 조회하면서 각 콘서트의 공연장 정보도 함께 가져온다고 가정한다면,
1. 콘서트 목록 조회 쿼리 1번 실행 (10개 조회)
2. 각 콘서트마다 공연장 정보 조회 쿼리 10번 실행

총 11번(1 + 10)의 쿼리가 실행되는데, 이것이 N+1 문제입니다. N개의 데이터를 조회했는데 추가로 N번의 쿼리가 더 발생하는 거죠.

**해결 방법**

1. **Fetch Join (JPQL)**: 연관된 엔티티를 한 번의 쿼리로 조회
```java
SELECT c FROM Concert c JOIN FETCH c.venue
```

2. **@EntityGraph**: 어노테이션으로 간단하게 Fetch Join 효과
```java
@EntityGraph(attributePaths = {"venue"})
List<Concert> findAll();
```

3. **Batch Size**: 연관 데이터를 IN 절로 한 번에 조회
```java
@BatchSize(size = 100)
private List<Performance> performances;
```

## **예상 꼬리질문**

**Q1. Fetch Join과 일반 Join의 차이는 무엇인가요?**

A. 일반 Join은 SELECT 절에 명시된 엔티티만 조회하고 연관 엔티티는 프록시 객체로 남겨둡니다. 반면 Fetch Join은 연관된 엔티티까지 실제 데이터로 즉시 로딩합니다.

예를 들어 `SELECT c FROM Concert c JOIN c.venue`는 Concert만 조회하고 venue는 프록시로 남아있어, 나중에 venue 정보를 사용할 때 추가 쿼리가 발생합니다. 하지만 `SELECT c FROM Concert c JOIN FETCH c.venue`는 Concert와 venue를 한 번에 모두 조회해서 추가 쿼리가 발생하지 않습니다.

---

