## 📋 질문 목록
- [Q1. SQL과 NoSQL 데이터베이스의 차이점](#1-sql과-nosql-데이터베이스의-차이점은-무엇인가요-어떤-상황에-어떤-데이터베이스를-선택하는-게-좋을까요)
- [Q2. 재고 동시성 문제 해결 방법](#2-재고-동시성-문제가-발생했을-때-어떤-해결-방법을-선택하실-건가요)


## 1. SQL과 NoSQL 데이터베이스의 차이점은 무엇인가요? 어떤 상황에 어떤 데이터베이스를 선택하는 게 좋을까요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.16)

**답변**

SQL은 데이터 간의 **관계를 중심**으로 설계된 관계형 데이터베이스로, **정해진 스키마 구조**를 따라 테이블에 데이터를 저장합니다. 여러 테이블 간의 관계를 외래키로 연결하고 JOIN을 통해 데이터를 조회합니다.

NoSQL은 관계보다는 **데이터 자체를 중심**으로 설계된 비관계형 데이터베이스로, **유연한 구조**를 가지고 있어 스키마 변경이 자유롭습니다. 문서, 키-값, 그래프 등 다양한 형태로 데이터를 저장합니다.

**선택 기준**
- SQL: 데이터 간 관계가 복잡하고 정형화된 구조가 필요할 때, 데이터 정합성과 트랜잭션이 중요한 금융/회계 시스템
- NoSQL: 관계보다 빠른 읽기/쓰기가 중요하고, 구조 변경이 잦을 때, 대용량 비정형 데이터를 다루는 경우


## **예상 꼬리질문**

**Q1. 정형과 비정형 데이터는 어떠한 차이가 있는걸까요?**

A. 정형 데이터는 미리 정의된 구조(스키마)에 따라 행과 열로 정리된 데이터입니다. 예를 들어 사용자 테이블에 id, name, email 같은 고정된 필드가 있는 경우죠. 

비정형 데이터는 정해진 구조 없이 자유로운 형태로 저장되는 데이터입니다. 예를 들어 SNS 게시물처럼 어떤 글은 텍스트만 있고, 어떤 글은 이미지와 태그가 추가되는 식으로 각 데이터의 구조가 다를 수 있습니다. 반정형 데이터(JSON, XML)도 있는데, 이는 일정한 구조는 있지만 스키마만큼 엄격하지는 않습니다.


**Q2. NoSQL이 SQL보다 속도 측면이나 데이터를 유연하게 저장할 수 있다는 점에서 더욱 장점이 많은 것 같은데, 실제로는 RDBMS가 많이 사용되는 이유는 무엇일까요?**

A. 가장 큰 이유는 데이터의 안정성과 무결성 검증이 편하기 때문입니다.
SQL은 스키마를 통해 데이터 타입과 제약조건을 강제하고, ACID 트랜잭션으로 데이터 정합성을 보장합니다. 예를 들어 계좌이체처럼 "A에서 돈을 빼고 B에 넣는" 작업이 반드시 함께 성공하거나 함께 실패해야 하는 경우, SQL의 트랜잭션이 이를 자동으로 보장해줍니다.
또한 외래키 제약조건으로 관계의 무결성을 데이터베이스 레벨에서 검증할 수 있어, 잘못된 데이터가 들어가는 것을 원천적으로 막을 수 있습니다.
금융, 전자상거래, 의료 시스템처럼 데이터 오류가 치명적인 분야에서는 이러한 안정성이 속도나 유연성보다 훨씬 중요하기 때문에 RDBMS를 선호합니다.

---

## 2. 재고 동시성 문제가 발생했을 때 어떤 해결 방법을 선택하실 건가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.22)

**답변**
**낙관적 락**을 우선적으로 고려할 것 같습니다.

재고 동시성 문제는 여러 사용자가 동시에 같은 상품을 구매할 때 발생하는데, 대부분의 이커머스 환경에서는 실제로 충돌이 자주 발생하지 않기 때문입니다. 낙관적 락은 버전 필드나 타임스탬프를 이용해 데이터 수정 시점에만 충돌을 체크하므로, 읽기 작업이 많은 환경에서 성능상 유리합니다.

구현 방식:
1. 상품 테이블에 version 컬럼 추가
2. UPDATE 시 WHERE 절에 version 조건 추가
3. 업데이트된 row가 0개면 재시도 또는 실패 처리

만약 충돌이 매우 빈번한 상황(예: 한정 수량 이벤트)이라면 비관적 락이나 Redis를 이용한 분산 락을 고려하겠지만, 일반적인 상황에서는 낙관적 락이 시스템 성능과 사용자 경험 측면에서 균형잡힌 선택이라고 생각합니다.

## **예상 꼬리질문**

**Q1. 낙관적 락과 비관적 락의 차이점**

A. 낙관적 락은 "충돌이 거의 일어나지 않을 것"이라고 낙관적으로 가정하는 방식입니다. 데이터를 읽을 때는 락을 걸지 않고, 수정하는 시점에 다른 트랜잭션이 데이터를 변경했는지 확인합니다. JPA의 @Version 어노테이션처럼 버전 번호를 이용해 구현합니다.

비관적 락은 "충돌이 자주 일어날 것"이라고 비관적으로 가정하고, 데이터를 읽는 시점부터 락을 겁니다. SELECT ... FOR UPDATE 구문을 사용해 다른 트랜잭션이 해당 row에 접근하지 못하도록 막습니다. 충돌은 확실히 방지하지만, 락 대기 시간으로 인한 성능 저하와 데드락 위험이 있습니다.

**Q2. MVCC란 무엇인가요? 이것과 락은 어떤 관계가 있나요?**

A. MVCC(Multi-Version Concurrency Control)는 데이터베이스가 동시성을 처리하는 기본 메커니즘입니다. 각 트랜잭션이 데이터의 특정 시점 버전(스냅샷)을 보도록 해서, 읽기 작업이 쓰기 작업을 블로킹하지 않도록 합니다.

예를 들어 MySQL InnoDB에서는 Undo Log를 이용해 여러 버전의 데이터를 관리합니다. 트랜잭션 A가 데이터를 수정 중이어도, 트랜잭션 B는 이전 버전의 데이터를 읽을 수 있어 읽기 성능이 향상됩니다.

하지만 MVCC만으로는 두 트랜잭션이 동시에 같은 데이터를 수정해서 한 쪽 변경사항이 사라지는 문제(Lost Update 문제)를 완전히 해결할 수 없어서, 재고 같은 중요한 데이터는 추가적인 락 메커니즘이 필요합니다.

**Q3. 실무에서 Redis를 이용한 분산 락은 언제 사용하나요?**

A. MSA 환경에서 여러 서버 인스턴스가 동시에 같은 자원에 접근할 때 사용합니다. DB 레벨의 락은 단일 데이터베이스 내에서만 동작하지만, 분산 락은 여러 애플리케이션 서버 간의 동시성을 제어할 수 있습니다.

예를 들어 선착순 이벤트에서 Redis의 SETNX 명령어와 TTL을 조합해 락을 구현합니다. 다만 Redis 장애 시 전체 시스템이 영향받을 수 있어 고가용성 구성이 필수입니다.
