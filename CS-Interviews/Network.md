## 📚 질문 목록
1. [RESTful API란? REST의 특징](#1-restful-api란-무엇인가요-rest의-특징은-무엇인지-restful하게-api를-설계한다는-것은-어떤-의미인지-설명해주세요)
2. [동기(Sync) 방식과 비동기(Async) 방식의 차이점은 무엇인가요?](#2-동기sync-방식과-비동기async-방식의-차이점은-무엇인가요)
3. [웹 서버(Web Server)와 WAS(Web Application Server)의 차이점은 무엇인가요?](#3-웹-서버web-server와-wasweb-application-server의-차이점은-무엇인가요)
4. [OSI 7계층 모델에 대해 아는 대로 설명해주세요.](#4-osi-7계층-모델에-대해-아는-대로-설명해주세요)
5. [JWT(JSON Web Token)란 무엇이고, 왜 사용하나요?](#5-jwtjson-web-token란-무엇이고-왜-사용하나요)
6. [로드 밸런싱(Load Balancing)이란 무엇이고, 왜 필요한가요?](#6-로드-밸런싱load-balancing이란-무엇이고-왜-필요한가요)
7. [CORS(Cross-Origin Resource Sharing)란 무엇이고, 왜 발생하나요?](#7-corscross-origin-resource-sharing란-무엇이고-왜-발생하나요)
8. [메시지 큐(Message Queue)란 무엇이고, 언제 사용하나요?](#8-메시지-큐message-queue란-무엇이고-언제-사용하나요)
9. [API Gateway란 무엇이고, 왜 사용하나요?](#9-api-gateway란-무엇이고-왜-사용하나요)

## 1. RESTful API란 무엇인가요? REST의 특징은 무엇인지, 'RESTful하게 API를 설계한다'는 것은 어떤 의미인지 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.21)

**답변**

REST는 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일입니다. RESTful API는 REST 원칙을 따르는 API를 말합니다.

**REST의 주요 특징**
- **무상태성(Stateless)**: 서버가 클라이언트의 상태를 저장하지 않습니다. 각 요청은 독립적이며 필요한 모든 정보를 포함해야 합니다.
- **자원 중심 설계**: URL이 자원(Resource)을 나타냅니다. 예: `/users`, `/posts`
- **HTTP 메서드 활용**: GET(조회), POST(생성), PUT(전체 수정), PATCH(부분 수정), DELETE(삭제)를 명확히 구분해서 사용합니다.
- **계층화된 시스템**: 클라이언트는 서버의 구조를 알 필요 없이 API만으로 통신합니다.

**RESTful하게 API를 설계한다는 의미**

URL은 행위가 아닌 자원을 표현하고, HTTP 메서드로 행위를 나타내는 것입니다.

- 좋은 예: `GET /users/123`, `DELETE /users/123`
- 나쁜 예: `GET /getUser?id=123`, `POST /deleteUser`

또한 일관된 규칙을 사용하고(예: 복수형 명사 사용), 적절한 HTTP 상태 코드를 반환하며(200, 201, 404, 500 등), 명확하고 예측 가능한 구조를 유지하는 것을 의미합니다.


## **예상 꼬리질문**

**Q1. REST와 RESTful의 차이는 무엇인가요?**

A. REST는 아키텍처 원칙 그 자체를 말하고, RESTful은 REST 원칙을 잘 따르는 시스템을 표현하는 형용사입니다. 

예를 들어 "이 API는 RESTful하다"는 말은 REST의 원칙들(무상태성, 자원 중심 설계 등)을 잘 지켜서 설계되었다는 의미입니다. 반대로 REST 원칙을 일부만 따르거나 지키지 않으면 "RESTful하지 않다"고 표현합니다.


**Q2. RESTful API의 단점이나 한계는 무엇인가요?**

A. REST는 표준이 명확하지 않아서 개발자마다 해석이 다를 수 있습니다. 예를 들어 URL 설계 규칙이 팀마다 조금씩 다를 수 있습니다.

또한 복잡한 쿼리나 여러 자원을 한 번에 요청할 때 비효율적입니다. 예를 들어 사용자 정보와 그 사용자의 게시글, 댓글을 함께 가져오려면 여러 번 API를 호출해야 할 수 있습니다(Over-fetching/Under-fetching 문제).

이런 한계 때문에 최근에는 GraphQL 같은 대안 기술도 함께 사용되고 있습니다. GraphQL은 클라이언트가 필요한 데이터를 정확히 요청할 수 있어서 REST의 단점을 보완합니다.

---

## 2. 동기(Sync) 방식과 비동기(Async) 방식의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.03)

**답변**

동기는 작업들이 순차적으로 실행되는 방식으로, 한 작업이 시작되면 해당 작업이 완료될 때까지 다음 작업이 기다려야 합니다. 코드의 흐름이 직관적이고 이해하기 쉬우며 디버깅이 용이하다는 장점이 있지만, 작업이 오래 걸리면 전체 프로그램이 멈춰서 사용자 경험이 나빠질 수 있다는 단점이 있습니다. 

비동기는 작업의 완료 여부를 기다리지 않고 다른 작업을 동시에 실행할 수 있는 방식을 의미합니다. I/O 작업 중에도 다른 작업을 처리할 수 있어 효율적이며, 많은 동시 요청을 적은 리소스로 처리 가능하다는 장점이 있지만, 코드가 복잡해지고 실행 순서를 예측하기 어려워 디버깅이 어려울 수 있다는 단점이 있습니다.

외부 API를 호출하는 동안 다른 작업을 할 수 있다면 비동기가 효율적이지만, 단순한 CRUD 작업은 동기 방식이 코드가 더 명확합니다.

## **예상 꼬리질문**

**Q1.  스프링에서는 비동기 처리를 어떻게 구현하나요?**
A. 스프링은 여러 방식으로 비동기 처리를 지원합니다.
1. @Async 어노테이션 : 메서드에 붙이면 별도 스레드에서 비동기로 실행됩니다. @EnableAsync 설정이 필요합니다.
2. CompletableFuture: 비동기 작업의 결과를 처리하고 조합할 수 있습니다.
3. SpringWebFlux: Reactor 기반의 완전한 비동기/논플로킹 프레임워크로, 대량의 동시 요청 처리에 적합합니다.

전통적인 Spring MVC는 요청당 하나의 스레드를 할당하는 동기 방식이지만, WebFlux는 적은 스레드로 많은 요청을 처리할 수 있습니다.

---

## 3. 웹 서버(Web Server)와 WAS(Web Application Server)의 차이점은 무엇인가요? 
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.05)

**답변**

웹 서버와 WAS는 둘 다 웹 서비스를 제공하는 서버인데, 무엇을 처리하느냐에 따라 역할이 다릅니다.

**웹 서버**는 **정적 콘텐츠**를 처리합니다. 이미 만들어진 HTML 파일, CSS, JavaScript, 이미지 같은 고정된 파일들을 그대로 사용자에게 전달해주는 역할을 합니다. 대표적으로 Nginx, Apache가 있습니다.

**WAS**는 **동적 콘텐츠**를 처리합니다. 사용자 요청에 따라 프로그램을 실행하고, 데이터베이스를 조회하고, 비즈니스 로직을 처리해서 그때그때 결과를 만들어냅니다. 예를 들어 로그인, 주문 내역 조회, 결제 처리 같은 복잡한 작업을 수행합니다. Tomcat, Node.js, Django 등이 WAS입니다.

웹 서버와 WAS는 함께 사용합니다. 웹 서버가 먼저 요청을 받아 정적 파일을 바로 처리하고, 동적 처리가 필요한 요청만 WAS로 넘겨주는 방식입니다. 
웹 서버를 앞에 두면 정적 파일 처리가 빨라지고, WAS의 부담을 줄일 수 있어서 효율적입니다.


## **예상 꼬리질문**

**Q1. 정적 콘텐츠와 동적 콘텐츠를 구분하는 기준이 뭔가요?**

A. 미리 만들어져 있느냐, 그때그때 만드느냐의 차이입니다.

정적 콘텐츠는 서버에 파일이 그대로 저장되어 있어서, 누가 언제 요청하든 같은 내용을 보여줍니다.

동적 콘텐츠는 요청할 때마다 프로그램이 실행되어 결과가 달라집니다. 데이터베이스 조회가 필요하거나, 사용자 입력에 따라 계산이 필요한 경우가 대부분 동적 콘텐츠입니다.


**Q2. 리버스 프록시(Reverse Proxy)는 웹 서버와 어떤 관계인가요?**

A. 리버스 프록시는 웹 서버가 수행하는 역할 중 하나입니다.

일반적으로 Nginx 같은 웹 서버를 리버스 프록시로 사용해서, 클라이언트 요청을 받아 뒤쪽의 WAS들에게 전달하고 응답을 다시 클라이언트에게 돌려주는 중개자 역할을 합니다.

여러 WAS로 요청을 분산시킬 수 있고(로드밸런싱), 특정 WAS가 죽어도 다른 WAS로 요청을 돌릴 수 있으며(무중단 배포), WAS의 실제 주소를 숨겨서 보안도 강화되는 장점이 있습니다. 
실제 서비스에서 "Nginx + Tomcat" 조합을 많이 쓰는 이유가 이런 리버스 프록시 기능 때문입니다.

---

## 4. OSI 7계층 모델에 대해 아는 대로 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.06)

**답변**

OSI 7계층은 **네트워크 통신 과정을 7단계로 나눈 표준 모델**입니다. 통신이 일어나는 과정을 단계별로 나눠서 각 계층이 독립적인 역할을 수행하도록 설계되었습니다. 문제가 생기면 어느 계층에서 발생했는지 파악하기 쉽고, 특정 계층만 교체하거나 업그레이드할 수 있어서 유지보수가 편리합니다.

**7. Application (응용 계층)**
사용자가 실제로 사용하는 애플리케이션이 동작하는 계층입니다. HTTP, FTP, SMTP, DNS 같은 프로토콜이 여기서 작동하며, 웹 브라우저나 이메일 클라이언트가 이 계층에서 동작합니다.

**6. Presentation (표현 계층)**
데이터의 형식을 변환하고 암호화/복호화를 담당합니다. 예를 들어 JPEG 이미지를 압축하거나, HTTPS의 SSL/TLS 암호화가 이 계층에서 이루어집니다. 서로 다른 시스템 간에 데이터를 이해할 수 있도록 번역하는 역할을 합니다.

**5. Session (세션 계층)**
통신 연결을 관리합니다. 데이터 교환의 시작과 종료를 제어하고, 연결이 끊어졌을 때 복구하는 역할을 합니다.

**4. Transport (전송 계층)**
데이터를 신뢰성 있게 전달하는 역할입니다. TCP와 UDP가 여기서 동작하며, 포트 번호로 어떤 애플리케이션에게 데이터를 전달할지 결정합니다. TCP는 데이터가 순서대로 도착하는지 확인하고, 손실되면 재전송합니다.

**3. Network (네트워크 계층)**
데이터를 목적지까지 전달하는 경로를 찾습니다. IP 주소를 사용해서 라우팅을 수행하며, 라우터가 이 계층에서 동작합니다. 여러 네트워크를 거쳐서 최종 목적지까지 패킷을 전달하는 역할을 합니다.

**2. Data Link (데이터 링크 계층)**
같은 네트워크 내에서 직접 연결된 기기 간의 데이터 전송을 담당합니다. MAC 주소를 사용하며, 이더넷 프레임을 만들고 오류를 검출합니다. 스위치가 이 계층에서 동작합니다.

**1. Physical (물리 계층)**
실제 물리적인 연결과 전기 신호를 다룹니다. 케이블, 전파, 광섬유 같은 물리적 매체를 통해 비트(0과 1)를 전송합니다. 허브나 리피터 같은 장비가 이 계층에서 동작합니다.


## **예상 꼬리질문**

**Q1. 실제로는 TCP/IP 모델을 더 많이 사용하는데, OSI 7계층과 어떻게 다른가요?**

A. TCP/IP 모델은 OSI 7계층을 4계층으로 단순화한 **실용적인 모델**입니다.

OSI는 이론적/표준적 모델이고, TCP/IP는 실제 인터넷에서 사용되는 모델입니다. TCP/IP는 Application(응용+표현+세션), Transport(전송), Internet(네트워크), Network Access(데이터링크+물리) 이렇게 4계층으로 구성됩니다.

개발자들은 OSI 7계층으로 개념을 이해하고, 실제 구현할 때는 TCP/IP 모델을 사용하는 경우가 많습니다. OSI는 문제를 진단하거나 설명할 때 유용한 참조 모델 역할을 합니다.


**Q2. 3-way handshake는 OSI 7계층 중 어느 계층에서 일어나나요?**

A. Transport 계층(4계층)에서 일어납니다.

3-way handshake는 TCP 연결을 수립하는 과정인데, TCP가 Transport 계층의 프로토콜이기 때문입니다. SYN, SYN-ACK, ACK 패킷을 주고받으면서 신뢰성 있는 연결을 만듭니다.

---

## 5. JWT(JSON Web Token)란 무엇이고, 왜 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.12)

**답변**

JWT는 사용자 인증 정보를 안전하게 전달하기 위한 토큰 기반 인증 방식입니다. JSON 형태로 정보를 담고 있으며, 헤더, 페이로드, 서명 세 부분으로 구성되어 있습니다.

JWT는 사용자가 로그인하면 서버가 토큰을 발급해주고, 이후 요청마다 클라이언트가 이 토큰을 HTTP 헤더에 담아 보내는 방식으로 동작합니다. 서버는 토큰의 서명을 검증해서 사용자를 인증합니다.

JWT를 사용하는 이유는 크게 세 가지가 있습니다.

첫째, **무상태 인증**이 가능합니다. 서버가 세션 정보를 저장할 필요 없이, 토큰 자체에 필요한 정보가 담겨 있어서 서버 부담이 줄어듭니다. 여러 서버로 확장하기도 쉽습니다.

둘째, **마이크로서비스나 API 서버에 적합**합니다. 서로 다른 도메인 간에도 토큰만 있으면 인증이 가능해서, RESTful API나 SPA(Single Page Application)에서 많이 사용됩니다.

셋째, **모바일 앱에서 사용하기 편리**합니다. 쿠키 기반 인증은 브라우저 환경에 의존하는데, JWT는 어떤 플랫폼에서든 HTTP 헤더에 담아 보낼 수 있습니다.


## **예상 꼬리질문**

**Q1. JWT와 세션/쿠키 방식의 차이점은 무엇인가요?**

A. 가장 큰 차이는 "인증 정보를 어디에 저장하느냐"입니다.

**세션/쿠키 방식**은 서버가 세션 정보를 메모리나 DB에 저장하고, 클라이언트에게는 세션 ID만 쿠키로 전달합니다. 클라이언트가 요청할 때마다 쿠키에 담긴 세션 ID를 보내면, 서버가 저장된 세션 정보를 조회해서 사용자를 확인합니다. 상태를 서버에서 관리하기 때문에 **Stateful**합니다.

**JWT 방식**은 서버가 토큰을 발급한 후 저장하지 않고, 클라이언트가 토큰을 보관합니다. 요청마다 토큰을 보내면 서버는 서명만 검증하면 되기 때문에 **Stateless**합니다.

- 세션: 서버에서 즉시 세션을 삭제할 수 있어서 보안성이 높지만, 서버 메모리를 사용하고 확장이 어려움
- JWT: 서버 부담이 적고 확장이 쉽지만, 토큰이 탈취되면 만료 전까지 막을 방법이 없어서 보안에 주의 필요

**Q2. JWT의 보안 취약점은 무엇이고, 어떻게 보완하나요?**

A. JWT의 가장 큰 취약점은 토큰이 탈취되면 만료 전까지 막을 방법이 없다는 점입니다.

서버가 토큰을 저장하지 않는 Stateless 특성 때문에, 토큰을 강제로 무효화할 수 없습니다. 예를 들어 사용자가 로그아웃해도 탈취된 토큰은 여전히 유효합니다.

보완 방법:

1. **짧은 만료 시간 설정**: Access Token의 유효 기간을 15분~1시간 정도로 짧게 설정합니다.

2. **Refresh Token 사용**: 긴 유효기간을 가진 Refresh Token을 함께 발급해서, Access Token이 만료되면 Refresh Token으로 새로 발급받는 방식입니다. Refresh Token은 서버에 저장해서 관리할 수 있습니다.

3. **HTTPS 사용**: 토큰이 네트워크에서 탈취되지 않도록 HTTPS로 암호화된 통신을 사용합니다.

4. **민감한 정보 제외**: Payload는 디코딩만 하면 볼 수 있기 때문에, 비밀번호나 개인정보 같은 민감한 데이터는 절대 넣지 않습니다.

---

## 6. 로드 밸런싱(Load Balancing)이란 무엇이고, 왜 필요한가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.14)

**답변**

로드 밸런싱은 클라이언트의 요청을 여러 서버로 분산해서 처리하는 기술입니다. 로드 밸런서가 중간에서 트래픽을 받아 서버들에 골고루 나눠주기 때문에, 특정 서버에만 부하가 몰리는 것을 방지할 수 있습니다.
예를 들어 쇼핑몰에 동시에 많은 사용자가 접속하면, 한 서버만으로는 감당할 수 없어 속도가 느려지거나 장애가 발생할 수 있습니다. 로드 밸런서를 사용하면 여러 대의 서버가 나눠서 처리하므로 더 안정적으로 서비스할 수 있습니다.
또한 한 서버에 장애가 발생하더라도 로드 밸런서가 자동으로 다른 정상 서버로 트래픽을 보내주어 서비스가 계속 유지됩니다. 이처럼 로드 밸런싱은 고가용성과 확장성을 보장하는 핵심 기술입니다.

---

## 7. CORS(Cross-Origin Resource Sharing)란 무엇이고, 왜 발생하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.17)

**답변**

CORS는 교차 출처 리소스 공유로, 웹 애플리케이션에서 서로 다른 도메인 간에 리소스를 공유할 수 있도록 허용하는 보안 메커니즘입니다.

웹 브라우저는 기본적으로 Same-Origin Policy(동일 출처 정책)이라는 보안 정책을 따릅니다. 이는 악의적인 사이트가 다른 사이트의 데이터를 무단으로 가져가는 것을 막기 위한 것입니다. 
예를 들어 malicious.com에서 bank.com의 API를 마음대로 호출할 수 없도록 막는 것이죠.

하지만 실제 웹 개발에서는 프론트엔드(localhost:3000)와 백엔드(localhost:8080)가 다른 포트에서 실행되거나, 프론트엔드는 example.com이고 API 서버는 api.example.com처럼 도메인이 다른 경우가 흔합니다. 
이때 CORS 정책을 통해 "이 출처는 신뢰할 수 있으니 허용한다"고 명시적으로 설정할 수 있습니다.

CORS 에러가 발생하는 이유:
브라우저가 다른 도메인으로 요청을 보낼 때, 서버가 적절한 CORS 헤더를 응답에 포함하지 않으면 브라우저가 요청을 차단합니다. 이때 CORS policy 에러가 나타납니다.
중요한 점은 서버는 정상적으로 응답을 보냈지만, 브라우저가 차단한다는 것입니다. 보안상의 이유로 브라우저가 응답을 받지 못하게 막는 것이죠.

해결 방법
서버에서 응답 헤더에 CORS 관련 설정을 추가해야 합니다.

## **예상 꼬리질문**

**Q3. 왜 Postman이나 curl에서는 CORS 에러가 안 나나요?**
A. CORS는 브라우저의 보안 정책이기 때문입니다.
Postman, curl, 서버 간 통신 등은 브라우저를 거치지 않으므로 Same-Origin Policy가 적용되지 않습니다. 이들은 단순히 HTTP 요청을 보내고 응답을 받기만 하기 때문에 CORS 제약이 없습니다.
반면 브라우저는 사용자의 쿠키나 세션 정보를 자동으로 포함해서 요청을 보낼 수 있어서, 악의적인 사이트가 이를 악용할 수 있습니다. 그래서 브라우저는 CORS 정책으로 교차 출처 요청을 제한하는 것입니다.

---

## 8. 메시지 큐(Message Queue)란 무엇이고, 언제 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.18)

**답변**

메시지 큐는 애플리케이션 간에 **메시지를 비동기적으로 주고받을 수 있도록 중간에서 메시지를 저장하고 전달하는 미들웨어**입니다. 
마치 우체통처럼, 발신자는 메시지를 넣어두고 바로 다른 일을 할 수 있고, 수신자는 준비가 되었을 때 메시지를 꺼내서 처리합니다.

**메시지 큐의 주요 역할**

1. **비동기 통신 지원**: 발신자와 수신자가 동시에 작동하지 않아도 메시지를 주고받을 수 있습니다. 발신자는 메시지를 큐에 넣고 바로 다음 작업을 할 수 있어, 응답을 기다리느라 멈춰있지 않습니다.

2. **서비스 간 결합도 완화**: 메시지 큐가 중간에서 메시지를 관리하므로, 발신자는 수신자가 누구인지, 어떻게 처리하는지 알 필요가 없습니다. 이는 시스템 확장성과 유지보수성을 높여줍니다.

3. **부하 분산 및 안정성 보장**: 갑자기 많은 요청이 들어와도 큐에 쌓아두고 처리 가능한 속도로 순차적으로 처리할 수 있어, 시스템이 과부하로 다운되는 것을 방지합니다.

**언제 사용하나요?**

**1. 트래픽 급증 상황**
쇼핑몰에서 특가 이벤트로 주문이 폭주하는 경우, 모든 주문을 동시에 처리하려고 하면 서버가 다운될 수 있습니다. 대신 주문 요청을 메시지 큐에 쌓아두고, 주문 처리 서버가 하나씩 안전하게 처리하도록 할 수 있습니다.

**2. 시간이 오래 걸리는 작업**
회원가입 후 웰컴 이메일을 발송하거나, 동영상을 인코딩하는 등 시간이 오래 걸리는 작업을 사용자가 기다리게 하면 안 됩니다. 이런 작업을 메시지 큐에 넣어두고 백그라운드에서 처리하면, 사용자는 즉시 다음 화면으로 넘어갈 수 있습니다.

**3. 서비스 간 통신이 필요한 MSA 환경**
마이크로서비스 아키텍처에서 주문 서비스, 결제 서비스, 알림 서비스가 분리되어 있을 때, 메시지 큐를 통해 "주문 완료" 이벤트를 발행하면 각 서비스가 필요한 작업을 독립적으로 수행할 수 있습니다.

대표적인 메시지 큐로는 RabbitMQ, Apache Kafka, AWS SQS, Redis 등이 있습니다.


## **예상 꼬리질문**

**Q1. 메시지 큐를 사용하면 메시지가 손실될 위험은 없나요?**

A. 메시지 큐는 여러 방법으로 메시지 손실을 방지합니다.

**1. 영속성**: 메시지를 디스크에 저장해서, 메시지 큐 서버가 재시작되어도 메시지가 사라지지 않도록 합니다. RabbitMQ는 메시지를 durable로 설정할 수 있고, Kafka는 기본적으로 디스크에 저장합니다.

**2. ACK(Acknowledgement) 메커니즘**: 수신자가 메시지를 성공적으로 처리한 후에만 큐에서 삭제합니다. 처리 중 오류가 발생하면 메시지가 큐에 남아있어 다시 처리할 수 있습니다.

**3. 복제**: 메시지를 여러 서버에 복제해서 저장합니다. 한 서버에 장애가 나도 다른 서버에 메시지가 남아있습니다.

다만 이런 안정성 기능들은 성능과 트레이드오프 관계에 있습니다. 영속성을 활성화하면 디스크 I/O로 인해 처리 속도가 느려질 수 있으므로, 상황에 맞게 설정해야 합니다.


**Q2. 메시지 큐와 데이터베이스의 차이점은 무엇인가요?**

A. 둘 다 데이터를 저장하지만, 목적과 특성이 완전히 다릅니다.

**메시지 큐**:
- 목적: 일시적인 메시지 전달
- 특징: 메시지를 읽으면 삭제됨
- 순서: FIFO
- 조회: 복잡한 쿼리 불가, 순차적으로만 읽음
- 사용 예: 이메일 발송 작업, 주문 처리 작업

**데이터베이스**:
- 목적: 영구적인 데이터 저장
- 특징: 데이터를 읽어도 삭제되지 않음
- 순서: 인덱스, 정렬 등 자유로운 접근
- 조회: WHERE, JOIN 등 복잡한 쿼리 가능
- 사용 예: 사용자 정보, 주문 내역

예를 들어 주문 시스템에서:
- 주문 데이터 자체는 **데이터베이스**에 저장
- "이 주문을 처리해라"는 작업 명령은 **메시지 큐**에 전달

---

## 9. API Gateway란 무엇이고, 왜 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.21)

**답변**

API Gateway는 클라이언트와 백엔드 서비스 사이에서 **모든 API 요청을 받아서 적절한 서비스로 전달**해주는 단일 진입점(Single Entry Point) 역할을 하는 서버입니다.

**주요 기능**
- **라우팅**: 클라이언트 요청을 분석해서 적절한 백엔드 서비스로 전달
- **인증/인가**: API 키, JWT 토큰 등으로 요청을 검증하고 권한을 확인
- **로드 밸런싱**: 여러 서버로 트래픽을 분산
- **속도 제한(Rate Limiting)**: 특정 클라이언트의 과도한 요청을 제한
- **캐싱**: 자주 요청되는 데이터를 캐시해서 응답 속도 향상
- **로깅/모니터링**: 모든 API 요청을 한곳에서 기록하고 모니터링

**예시**
쇼핑몰 앱에서 상품 조회, 주문, 결제, 회원 정보가 각각 다른 마이크로서비스로 구성되어 있다고 가정하면:

```
[모바일 앱] → [API Gateway] → 상품 서비스 (port 8001)
                            → 주문 서비스 (port 8002)  
                            → 결제 서비스 (port 8003)
                            → 회원 서비스 (port 8004)
```

클라이언트는 `https://api.shop.com`이라는 하나의 주소만 알면 되고, API Gateway가 `/products`, `/orders`, `/payments` 같은 경로를 보고 알맞은 서비스로 요청을 전달합니다.

**사용하는 이유**
- **단일 진입점**: 클라이언트가 여러 서비스의 주소를 알 필요 없이 하나의 주소로만 접근
- **공통 기능 통합**: 인증, 로깅 같은 공통 기능을 각 서비스마다 구현할 필요 없이 Gateway에서 한 번만 처리
- **보안 강화**: 내부 서비스를 외부에 직접 노출하지 않고 Gateway를 통해서만 접근하게 함
- **유연성**: 백엔드 서비스의 구조가 바뀌어도 클라이언트는 수정할 필요가 없음


## **예상 꼬리질문**

**Q1. API Gateway의 단점은 무엇인가요?**

A. API Gateway를 도입하면 몇 가지 문제가 생길 수 있습니다.

- **단일 장애점(Single Point of Failure)**: 모든 요청이 API Gateway를 거치기 때문에 Gateway에 문제가 생기면 전체 시스템이 마비됩니다. 이를 해결하기 위해 Gateway를 여러 대 두고 로드밸런서로 분산시키는 방식을 사용합니다.

- **성능 병목**: 모든 트래픽이 Gateway를 거쳐서 가기 때문에, Gateway 자체가 병목이 될 수 있습니다. 충분한 성능과 확장성을 확보해야 합니다.

- **추가적인 네트워크 홉**: 클라이언트와 서비스 사이에 한 단계가 추가되므로 약간의 지연시간(latency)이 발생합니다.

- **복잡도 증가**: 시스템에 새로운 컴포넌트가 추가되므로 관리해야 할 대상이 늘어나고, Gateway 설정을 잘못하면 문제가 발생할 수 있습니다.


**Q2. API Gateway와 Load Balancer의 차이점은 무엇인가요?**

A. 둘 다 트래픽을 분산시키는 역할을 하지만, 목적과 기능이 다릅니다.

**Load Balancer**는 **같은 서비스**의 여러 인스턴스에 트래픽을 균등하게 분산시키는 것이 주목적입니다. 예를 들어 주문 서비스가 3대 있으면, 요청을 3대에 골고루 나눠줍니다. 주로 L4(Transport Layer) 또는 L7(Application Layer) 수준에서 동작합니다.

**API Gateway**는 트래픽 분산뿐만 아니라 **다양한 서비스로 요청을 라우팅**하고, 인증, 캐싱, 속도 제한 같은 **비즈니스 로직**도 처리합니다. 주로 L7(Application Layer)에서 동작하며, HTTP 요청의 경로나 헤더를 분석해서 어느 서비스로 보낼지 결정합니다.

실제로는 둘을 함께 사용하기도 합니다:
```
[클라이언트] → [Load Balancer] → [API Gateway 1, 2, 3] → [각 마이크로서비스]
```

API Gateway 앞에 Load Balancer를 두어서 Gateway 자체의 가용성과 확장성을 높이는 구조입니다.

---

