## 📚 질문 목록
1. [RESTful API란? REST의 특징](#1-restful-api란-무엇인가요-rest의-특징은-무엇인지-restful하게-api를-설계한다는-것은-어떤-의미인지-설명해주세요)
2. [동기(Sync) 방식과 비동기(Async) 방식의 차이점은 무엇인가요?](#2-동기sync-방식과-비동기async-방식의-차이점은-무엇인가요)
3. [웹 서버(Web Server)와 WAS(Web Application Server)의 차이점은 무엇인가요?](#3-웹-서버web-server와-wasweb-application-server의-차이점은-무엇인가요)
4. [OSI 7계층 모델에 대해 아는 대로 설명해주세요.](#4-osi-7계층-모델에-대해-아는-대로-설명해주세요)
5. [JWT(JSON Web Token)란 무엇이고, 왜 사용하나요?](#5-jwtjson-web-token란-무엇이고-왜-사용하나요)
6. [로드 밸런싱(Load Balancing)이란 무엇이고, 왜 필요한가요?](#6-로드-밸런싱load-balancing이란-무엇이고-왜-필요한가요)
7. [CORS(Cross-Origin Resource Sharing)란 무엇이고, 왜 발생하나요?](#7-corscross-origin-resource-sharing란-무엇이고-왜-발생하나요)
8. [메시지 큐(Message Queue)란 무엇이고, 언제 사용하나요?](#8-메시지-큐message-queue란-무엇이고-언제-사용하나요)
9. [API Gateway란 무엇이고, 왜 사용하나요?](#9-api-gateway란-무엇이고-왜-사용하나요)
10. [Scale Up(수직 확장)과 Scale Out(수평 확장)의 차이점은 무엇인가요?](#10-scale-up수직-확장과-scale-out수평-확장의-차이점은-무엇인가요)
11. [Stateful과 Stateless의 차이점은 무엇인가요?](#11-stateful과-stateless의-차이점은-무엇인가요)
12. [OAuth 2.0이란 무엇이고, 어떤 상황에서 사용하나요?](#12-oauth-20이-무엇이고-어떤-상황에서-사용하나요)
13. [WebSocket이란 무엇이고, 기존 HTTP 통신과 어떤 차이가 있나요?](#13-websocket이란-무엇이고-기존-http-통신과-어떤-차이가-있나요-어떤-상황에서-websocket을-사용하나요)
14. [TCP와 UDP의 차이점은 무엇인가요?](#14-tcp와-udp의-차이점은-무엇인가요)
15. [HTTP와 HTTPS의 차이점은 무엇인가요?](#15-http와-https의-차이점은-무엇인가요)
16. [세션(Session)과 쿠키(Cookie)의 차이점은 무엇인가요?](#16-세션session과-쿠키cookie의-차이점은-무엇인가요)
17. [DNS(Domain Name System)란 무엇이며, 왜 필요한가요?](#17-dnsdomain-name-system란-무엇이며-왜-필요한가요)

## 1. RESTful API란 무엇인가요? REST의 특징은 무엇인지, 'RESTful하게 API를 설계한다'는 것은 어떤 의미인지 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.21)

**답변**

REST는 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일입니다. RESTful API는 REST 원칙을 따르는 API를 말합니다.

**REST의 주요 특징**
- **무상태성(Stateless)**: 서버가 클라이언트의 상태를 저장하지 않습니다. 각 요청은 독립적이며 필요한 모든 정보를 포함해야 합니다.
- **자원 중심 설계**: URL이 자원(Resource)을 나타냅니다. 예: `/users`, `/posts`
- **HTTP 메서드 활용**: GET(조회), POST(생성), PUT(전체 수정), PATCH(부분 수정), DELETE(삭제)를 명확히 구분해서 사용합니다.
- **계층화된 시스템**: 클라이언트는 서버의 구조를 알 필요 없이 API만으로 통신합니다.

**RESTful하게 API를 설계한다는 의미**

URL은 행위가 아닌 자원을 표현하고, HTTP 메서드로 행위를 나타내는 것입니다.

- 좋은 예: `GET /users/123`, `DELETE /users/123`
- 나쁜 예: `GET /getUser?id=123`, `POST /deleteUser`

또한 일관된 규칙을 사용하고(예: 복수형 명사 사용), 적절한 HTTP 상태 코드를 반환하며(200, 201, 404, 500 등), 명확하고 예측 가능한 구조를 유지하는 것을 의미합니다.


## **예상 꼬리질문**

**Q1. REST와 RESTful의 차이는 무엇인가요?**

A. REST는 아키텍처 원칙 그 자체를 말하고, RESTful은 REST 원칙을 잘 따르는 시스템을 표현하는 형용사입니다. 

예를 들어 "이 API는 RESTful하다"는 말은 REST의 원칙들(무상태성, 자원 중심 설계 등)을 잘 지켜서 설계되었다는 의미입니다. 반대로 REST 원칙을 일부만 따르거나 지키지 않으면 "RESTful하지 않다"고 표현합니다.


**Q2. RESTful API의 단점이나 한계는 무엇인가요?**

A. REST는 표준이 명확하지 않아서 개발자마다 해석이 다를 수 있습니다. 예를 들어 URL 설계 규칙이 팀마다 조금씩 다를 수 있습니다.

또한 복잡한 쿼리나 여러 자원을 한 번에 요청할 때 비효율적입니다. 예를 들어 사용자 정보와 그 사용자의 게시글, 댓글을 함께 가져오려면 여러 번 API를 호출해야 할 수 있습니다(Over-fetching/Under-fetching 문제).

이런 한계 때문에 최근에는 GraphQL 같은 대안 기술도 함께 사용되고 있습니다. GraphQL은 클라이언트가 필요한 데이터를 정확히 요청할 수 있어서 REST의 단점을 보완합니다.

---

## 2. 동기(Sync) 방식과 비동기(Async) 방식의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.03)

**답변**

동기는 작업들이 순차적으로 실행되는 방식으로, 한 작업이 시작되면 해당 작업이 완료될 때까지 다음 작업이 기다려야 합니다. 코드의 흐름이 직관적이고 이해하기 쉬우며 디버깅이 용이하다는 장점이 있지만, 작업이 오래 걸리면 전체 프로그램이 멈춰서 사용자 경험이 나빠질 수 있다는 단점이 있습니다. 

비동기는 작업의 완료 여부를 기다리지 않고 다른 작업을 동시에 실행할 수 있는 방식을 의미합니다. I/O 작업 중에도 다른 작업을 처리할 수 있어 효율적이며, 많은 동시 요청을 적은 리소스로 처리 가능하다는 장점이 있지만, 코드가 복잡해지고 실행 순서를 예측하기 어려워 디버깅이 어려울 수 있다는 단점이 있습니다.

외부 API를 호출하는 동안 다른 작업을 할 수 있다면 비동기가 효율적이지만, 단순한 CRUD 작업은 동기 방식이 코드가 더 명확합니다.

## **예상 꼬리질문**

**Q1.  스프링에서는 비동기 처리를 어떻게 구현하나요?**
A. 스프링은 여러 방식으로 비동기 처리를 지원합니다.
1. @Async 어노테이션 : 메서드에 붙이면 별도 스레드에서 비동기로 실행됩니다. @EnableAsync 설정이 필요합니다.
2. CompletableFuture: 비동기 작업의 결과를 처리하고 조합할 수 있습니다.
3. SpringWebFlux: Reactor 기반의 완전한 비동기/논플로킹 프레임워크로, 대량의 동시 요청 처리에 적합합니다.

전통적인 Spring MVC는 요청당 하나의 스레드를 할당하는 동기 방식이지만, WebFlux는 적은 스레드로 많은 요청을 처리할 수 있습니다.

---

## 3. 웹 서버(Web Server)와 WAS(Web Application Server)의 차이점은 무엇인가요? 
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.05)

**답변**

웹 서버와 WAS는 둘 다 웹 서비스를 제공하는 서버인데, 무엇을 처리하느냐에 따라 역할이 다릅니다.

**웹 서버**는 **정적 콘텐츠**를 처리합니다. 이미 만들어진 HTML 파일, CSS, JavaScript, 이미지 같은 고정된 파일들을 그대로 사용자에게 전달해주는 역할을 합니다. 대표적으로 Nginx, Apache가 있습니다.

**WAS**는 **동적 콘텐츠**를 처리합니다. 사용자 요청에 따라 프로그램을 실행하고, 데이터베이스를 조회하고, 비즈니스 로직을 처리해서 그때그때 결과를 만들어냅니다. 예를 들어 로그인, 주문 내역 조회, 결제 처리 같은 복잡한 작업을 수행합니다. Tomcat, Node.js, Django 등이 WAS입니다.

웹 서버와 WAS는 함께 사용합니다. 웹 서버가 먼저 요청을 받아 정적 파일을 바로 처리하고, 동적 처리가 필요한 요청만 WAS로 넘겨주는 방식입니다. 
웹 서버를 앞에 두면 정적 파일 처리가 빨라지고, WAS의 부담을 줄일 수 있어서 효율적입니다.


## **예상 꼬리질문**

**Q1. 정적 콘텐츠와 동적 콘텐츠를 구분하는 기준이 뭔가요?**

A. 미리 만들어져 있느냐, 그때그때 만드느냐의 차이입니다.

정적 콘텐츠는 서버에 파일이 그대로 저장되어 있어서, 누가 언제 요청하든 같은 내용을 보여줍니다.

동적 콘텐츠는 요청할 때마다 프로그램이 실행되어 결과가 달라집니다. 데이터베이스 조회가 필요하거나, 사용자 입력에 따라 계산이 필요한 경우가 대부분 동적 콘텐츠입니다.


**Q2. 리버스 프록시(Reverse Proxy)는 웹 서버와 어떤 관계인가요?**

A. 리버스 프록시는 웹 서버가 수행하는 역할 중 하나입니다.

일반적으로 Nginx 같은 웹 서버를 리버스 프록시로 사용해서, 클라이언트 요청을 받아 뒤쪽의 WAS들에게 전달하고 응답을 다시 클라이언트에게 돌려주는 중개자 역할을 합니다.

여러 WAS로 요청을 분산시킬 수 있고(로드밸런싱), 특정 WAS가 죽어도 다른 WAS로 요청을 돌릴 수 있으며(무중단 배포), WAS의 실제 주소를 숨겨서 보안도 강화되는 장점이 있습니다. 
실제 서비스에서 "Nginx + Tomcat" 조합을 많이 쓰는 이유가 이런 리버스 프록시 기능 때문입니다.

---

## 4. OSI 7계층 모델에 대해 아는 대로 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.06)

**답변**

OSI 7계층은 **네트워크 통신 과정을 7단계로 나눈 표준 모델**입니다. 통신이 일어나는 과정을 단계별로 나눠서 각 계층이 독립적인 역할을 수행하도록 설계되었습니다. 문제가 생기면 어느 계층에서 발생했는지 파악하기 쉽고, 특정 계층만 교체하거나 업그레이드할 수 있어서 유지보수가 편리합니다.

**7. Application (응용 계층)**
사용자가 실제로 사용하는 애플리케이션이 동작하는 계층입니다. HTTP, FTP, SMTP, DNS 같은 프로토콜이 여기서 작동하며, 웹 브라우저나 이메일 클라이언트가 이 계층에서 동작합니다.

**6. Presentation (표현 계층)**
데이터의 형식을 변환하고 암호화/복호화를 담당합니다. 예를 들어 JPEG 이미지를 압축하거나, HTTPS의 SSL/TLS 암호화가 이 계층에서 이루어집니다. 서로 다른 시스템 간에 데이터를 이해할 수 있도록 번역하는 역할을 합니다.

**5. Session (세션 계층)**
통신 연결을 관리합니다. 데이터 교환의 시작과 종료를 제어하고, 연결이 끊어졌을 때 복구하는 역할을 합니다.

**4. Transport (전송 계층)**
데이터를 신뢰성 있게 전달하는 역할입니다. TCP와 UDP가 여기서 동작하며, 포트 번호로 어떤 애플리케이션에게 데이터를 전달할지 결정합니다. TCP는 데이터가 순서대로 도착하는지 확인하고, 손실되면 재전송합니다.

**3. Network (네트워크 계층)**
데이터를 목적지까지 전달하는 경로를 찾습니다. IP 주소를 사용해서 라우팅을 수행하며, 라우터가 이 계층에서 동작합니다. 여러 네트워크를 거쳐서 최종 목적지까지 패킷을 전달하는 역할을 합니다.

**2. Data Link (데이터 링크 계층)**
같은 네트워크 내에서 직접 연결된 기기 간의 데이터 전송을 담당합니다. MAC 주소를 사용하며, 이더넷 프레임을 만들고 오류를 검출합니다. 스위치가 이 계층에서 동작합니다.

**1. Physical (물리 계층)**
실제 물리적인 연결과 전기 신호를 다룹니다. 케이블, 전파, 광섬유 같은 물리적 매체를 통해 비트(0과 1)를 전송합니다. 허브나 리피터 같은 장비가 이 계층에서 동작합니다.


## **예상 꼬리질문**

**Q1. 실제로는 TCP/IP 모델을 더 많이 사용하는데, OSI 7계층과 어떻게 다른가요?**

A. TCP/IP 모델은 OSI 7계층을 4계층으로 단순화한 **실용적인 모델**입니다.

OSI는 이론적/표준적 모델이고, TCP/IP는 실제 인터넷에서 사용되는 모델입니다. TCP/IP는 Application(응용+표현+세션), Transport(전송), Internet(네트워크), Network Access(데이터링크+물리) 이렇게 4계층으로 구성됩니다.

개발자들은 OSI 7계층으로 개념을 이해하고, 실제 구현할 때는 TCP/IP 모델을 사용하는 경우가 많습니다. OSI는 문제를 진단하거나 설명할 때 유용한 참조 모델 역할을 합니다.


**Q2. 3-way handshake는 OSI 7계층 중 어느 계층에서 일어나나요?**

A. Transport 계층(4계층)에서 일어납니다.

3-way handshake는 TCP 연결을 수립하는 과정인데, TCP가 Transport 계층의 프로토콜이기 때문입니다. SYN, SYN-ACK, ACK 패킷을 주고받으면서 신뢰성 있는 연결을 만듭니다.

---

## 5. JWT(JSON Web Token)란 무엇이고, 왜 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.12)

**답변**

JWT는 사용자 인증 정보를 안전하게 전달하기 위한 토큰 기반 인증 방식입니다. JSON 형태로 정보를 담고 있으며, 헤더, 페이로드, 서명 세 부분으로 구성되어 있습니다.

JWT는 사용자가 로그인하면 서버가 토큰을 발급해주고, 이후 요청마다 클라이언트가 이 토큰을 HTTP 헤더에 담아 보내는 방식으로 동작합니다. 서버는 토큰의 서명을 검증해서 사용자를 인증합니다.

JWT를 사용하는 이유는 크게 세 가지가 있습니다.

첫째, **무상태 인증**이 가능합니다. 서버가 세션 정보를 저장할 필요 없이, 토큰 자체에 필요한 정보가 담겨 있어서 서버 부담이 줄어듭니다. 여러 서버로 확장하기도 쉽습니다.

둘째, **마이크로서비스나 API 서버에 적합**합니다. 서로 다른 도메인 간에도 토큰만 있으면 인증이 가능해서, RESTful API나 SPA(Single Page Application)에서 많이 사용됩니다.

셋째, **모바일 앱에서 사용하기 편리**합니다. 쿠키 기반 인증은 브라우저 환경에 의존하는데, JWT는 어떤 플랫폼에서든 HTTP 헤더에 담아 보낼 수 있습니다.


## **예상 꼬리질문**

**Q1. JWT의 보안 취약점은 무엇이고, 어떻게 보완하나요?**

A. JWT의 가장 큰 취약점은 토큰이 탈취되면 만료 전까지 막을 방법이 없다는 점입니다.

서버가 토큰을 저장하지 않는 Stateless 특성 때문에, 토큰을 강제로 무효화할 수 없습니다. 예를 들어 사용자가 로그아웃해도 탈취된 토큰은 여전히 유효합니다.

보완 방법:

1. **짧은 만료 시간 설정**: Access Token의 유효 기간을 15분~1시간 정도로 짧게 설정합니다.

2. **Refresh Token 사용**: 긴 유효기간을 가진 Refresh Token을 함께 발급해서, Access Token이 만료되면 Refresh Token으로 새로 발급받는 방식입니다. Refresh Token은 서버에 저장해서 관리할 수 있습니다.

3. **HTTPS 사용**: 토큰이 네트워크에서 탈취되지 않도록 HTTPS로 암호화된 통신을 사용합니다.

4. **민감한 정보 제외**: Payload는 디코딩만 하면 볼 수 있기 때문에, 비밀번호나 개인정보 같은 민감한 데이터는 절대 넣지 않습니다.

---

## 6. 로드 밸런싱(Load Balancing)이란 무엇이고, 왜 필요한가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.14)

**답변**

로드 밸런싱은 클라이언트의 요청을 여러 서버로 분산해서 처리하는 기술입니다. 로드 밸런서가 중간에서 트래픽을 받아 서버들에 골고루 나눠주기 때문에, 특정 서버에만 부하가 몰리는 것을 방지할 수 있습니다.
예를 들어 쇼핑몰에 동시에 많은 사용자가 접속하면, 한 서버만으로는 감당할 수 없어 속도가 느려지거나 장애가 발생할 수 있습니다. 로드 밸런서를 사용하면 여러 대의 서버가 나눠서 처리하므로 더 안정적으로 서비스할 수 있습니다.
또한 한 서버에 장애가 발생하더라도 로드 밸런서가 자동으로 다른 정상 서버로 트래픽을 보내주어 서비스가 계속 유지됩니다. 이처럼 로드 밸런싱은 고가용성과 확장성을 보장하는 핵심 기술입니다.

---

## 7. CORS(Cross-Origin Resource Sharing)란 무엇이고, 왜 발생하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.17)

**답변**

CORS는 교차 출처 리소스 공유로, 웹 애플리케이션에서 서로 다른 도메인 간에 리소스를 공유할 수 있도록 허용하는 보안 메커니즘입니다.

웹 브라우저는 기본적으로 Same-Origin Policy(동일 출처 정책)이라는 보안 정책을 따릅니다. 이는 악의적인 사이트가 다른 사이트의 데이터를 무단으로 가져가는 것을 막기 위한 것입니다. 
예를 들어 malicious.com에서 bank.com의 API를 마음대로 호출할 수 없도록 막는 것이죠.

하지만 실제 웹 개발에서는 프론트엔드(localhost:3000)와 백엔드(localhost:8080)가 다른 포트에서 실행되거나, 프론트엔드는 example.com이고 API 서버는 api.example.com처럼 도메인이 다른 경우가 흔합니다. 
이때 CORS 정책을 통해 "이 출처는 신뢰할 수 있으니 허용한다"고 명시적으로 설정할 수 있습니다.

CORS 에러가 발생하는 이유:
브라우저가 다른 도메인으로 요청을 보낼 때, 서버가 적절한 CORS 헤더를 응답에 포함하지 않으면 브라우저가 요청을 차단합니다. 이때 CORS policy 에러가 나타납니다.
중요한 점은 서버는 정상적으로 응답을 보냈지만, 브라우저가 차단한다는 것입니다. 보안상의 이유로 브라우저가 응답을 받지 못하게 막는 것이죠.

해결 방법
서버에서 응답 헤더에 CORS 관련 설정을 추가해야 합니다.

## **예상 꼬리질문**

**Q3. 왜 Postman이나 curl에서는 CORS 에러가 안 나나요?**
A. CORS는 브라우저의 보안 정책이기 때문입니다.
Postman, curl, 서버 간 통신 등은 브라우저를 거치지 않으므로 Same-Origin Policy가 적용되지 않습니다. 이들은 단순히 HTTP 요청을 보내고 응답을 받기만 하기 때문에 CORS 제약이 없습니다.
반면 브라우저는 사용자의 쿠키나 세션 정보를 자동으로 포함해서 요청을 보낼 수 있어서, 악의적인 사이트가 이를 악용할 수 있습니다. 그래서 브라우저는 CORS 정책으로 교차 출처 요청을 제한하는 것입니다.

---

## 8. 메시지 큐(Message Queue)란 무엇이고, 언제 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.18)

**답변**

메시지 큐는 애플리케이션 간에 **메시지를 비동기적으로 주고받을 수 있도록 중간에서 메시지를 저장하고 전달하는 미들웨어**입니다. 
마치 우체통처럼, 발신자는 메시지를 넣어두고 바로 다른 일을 할 수 있고, 수신자는 준비가 되었을 때 메시지를 꺼내서 처리합니다.

**메시지 큐의 주요 역할**

1. **비동기 통신 지원**: 발신자와 수신자가 동시에 작동하지 않아도 메시지를 주고받을 수 있습니다. 발신자는 메시지를 큐에 넣고 바로 다음 작업을 할 수 있어, 응답을 기다리느라 멈춰있지 않습니다.

2. **서비스 간 결합도 완화**: 메시지 큐가 중간에서 메시지를 관리하므로, 발신자는 수신자가 누구인지, 어떻게 처리하는지 알 필요가 없습니다. 이는 시스템 확장성과 유지보수성을 높여줍니다.

3. **부하 분산 및 안정성 보장**: 갑자기 많은 요청이 들어와도 큐에 쌓아두고 처리 가능한 속도로 순차적으로 처리할 수 있어, 시스템이 과부하로 다운되는 것을 방지합니다.

**언제 사용하나요?**

**1. 트래픽 급증 상황**
쇼핑몰에서 특가 이벤트로 주문이 폭주하는 경우, 모든 주문을 동시에 처리하려고 하면 서버가 다운될 수 있습니다. 대신 주문 요청을 메시지 큐에 쌓아두고, 주문 처리 서버가 하나씩 안전하게 처리하도록 할 수 있습니다.

**2. 시간이 오래 걸리는 작업**
회원가입 후 웰컴 이메일을 발송하거나, 동영상을 인코딩하는 등 시간이 오래 걸리는 작업을 사용자가 기다리게 하면 안 됩니다. 이런 작업을 메시지 큐에 넣어두고 백그라운드에서 처리하면, 사용자는 즉시 다음 화면으로 넘어갈 수 있습니다.

**3. 서비스 간 통신이 필요한 MSA 환경**
마이크로서비스 아키텍처에서 주문 서비스, 결제 서비스, 알림 서비스가 분리되어 있을 때, 메시지 큐를 통해 "주문 완료" 이벤트를 발행하면 각 서비스가 필요한 작업을 독립적으로 수행할 수 있습니다.

대표적인 메시지 큐로는 RabbitMQ, Apache Kafka, AWS SQS, Redis 등이 있습니다.


## **예상 꼬리질문**

**Q1. 메시지 큐를 사용하면 메시지가 손실될 위험은 없나요?**

A. 메시지 큐는 여러 방법으로 메시지 손실을 방지합니다.

**1. 영속성**: 메시지를 디스크에 저장해서, 메시지 큐 서버가 재시작되어도 메시지가 사라지지 않도록 합니다. RabbitMQ는 메시지를 durable로 설정할 수 있고, Kafka는 기본적으로 디스크에 저장합니다.

**2. ACK(Acknowledgement) 메커니즘**: 수신자가 메시지를 성공적으로 처리한 후에만 큐에서 삭제합니다. 처리 중 오류가 발생하면 메시지가 큐에 남아있어 다시 처리할 수 있습니다.

**3. 복제**: 메시지를 여러 서버에 복제해서 저장합니다. 한 서버에 장애가 나도 다른 서버에 메시지가 남아있습니다.

다만 이런 안정성 기능들은 성능과 트레이드오프 관계에 있습니다. 영속성을 활성화하면 디스크 I/O로 인해 처리 속도가 느려질 수 있으므로, 상황에 맞게 설정해야 합니다.


**Q2. 메시지 큐와 데이터베이스의 차이점은 무엇인가요?**

A. 둘 다 데이터를 저장하지만, 목적과 특성이 완전히 다릅니다.

**메시지 큐**:
- 목적: 일시적인 메시지 전달
- 특징: 메시지를 읽으면 삭제됨
- 순서: FIFO
- 조회: 복잡한 쿼리 불가, 순차적으로만 읽음
- 사용 예: 이메일 발송 작업, 주문 처리 작업

**데이터베이스**:
- 목적: 영구적인 데이터 저장
- 특징: 데이터를 읽어도 삭제되지 않음
- 순서: 인덱스, 정렬 등 자유로운 접근
- 조회: WHERE, JOIN 등 복잡한 쿼리 가능
- 사용 예: 사용자 정보, 주문 내역

예를 들어 주문 시스템에서:
- 주문 데이터 자체는 **데이터베이스**에 저장
- "이 주문을 처리해라"는 작업 명령은 **메시지 큐**에 전달

---

## 9. API Gateway란 무엇이고, 왜 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.21)

**답변**

API Gateway는 클라이언트와 백엔드 서비스 사이에서 **모든 API 요청을 받아서 적절한 서비스로 전달**해주는 단일 진입점(Single Entry Point) 역할을 하는 서버입니다.

**주요 기능**
- **라우팅**: 클라이언트 요청을 분석해서 적절한 백엔드 서비스로 전달
- **인증/인가**: API 키, JWT 토큰 등으로 요청을 검증하고 권한을 확인
- **로드 밸런싱**: 여러 서버로 트래픽을 분산
- **속도 제한(Rate Limiting)**: 특정 클라이언트의 과도한 요청을 제한
- **캐싱**: 자주 요청되는 데이터를 캐시해서 응답 속도 향상
- **로깅/모니터링**: 모든 API 요청을 한곳에서 기록하고 모니터링

**예시**
쇼핑몰 앱에서 상품 조회, 주문, 결제, 회원 정보가 각각 다른 마이크로서비스로 구성되어 있다고 가정하면:

```
[모바일 앱] → [API Gateway] → 상품 서비스 (port 8001)
                            → 주문 서비스 (port 8002)  
                            → 결제 서비스 (port 8003)
                            → 회원 서비스 (port 8004)
```

클라이언트는 `https://api.shop.com`이라는 하나의 주소만 알면 되고, API Gateway가 `/products`, `/orders`, `/payments` 같은 경로를 보고 알맞은 서비스로 요청을 전달합니다.

**사용하는 이유**
- **단일 진입점**: 클라이언트가 여러 서비스의 주소를 알 필요 없이 하나의 주소로만 접근
- **공통 기능 통합**: 인증, 로깅 같은 공통 기능을 각 서비스마다 구현할 필요 없이 Gateway에서 한 번만 처리
- **보안 강화**: 내부 서비스를 외부에 직접 노출하지 않고 Gateway를 통해서만 접근하게 함
- **유연성**: 백엔드 서비스의 구조가 바뀌어도 클라이언트는 수정할 필요가 없음


## **예상 꼬리질문**

**Q1. API Gateway의 단점은 무엇인가요?**

A. API Gateway를 도입하면 몇 가지 문제가 생길 수 있습니다.

- **단일 장애점(Single Point of Failure)**: 모든 요청이 API Gateway를 거치기 때문에 Gateway에 문제가 생기면 전체 시스템이 마비됩니다. 이를 해결하기 위해 Gateway를 여러 대 두고 로드밸런서로 분산시키는 방식을 사용합니다.

- **성능 병목**: 모든 트래픽이 Gateway를 거쳐서 가기 때문에, Gateway 자체가 병목이 될 수 있습니다. 충분한 성능과 확장성을 확보해야 합니다.

- **추가적인 네트워크 홉**: 클라이언트와 서비스 사이에 한 단계가 추가되므로 약간의 지연시간(latency)이 발생합니다.

- **복잡도 증가**: 시스템에 새로운 컴포넌트가 추가되므로 관리해야 할 대상이 늘어나고, Gateway 설정을 잘못하면 문제가 발생할 수 있습니다.


**Q2. API Gateway와 Load Balancer의 차이점은 무엇인가요?**

A. 둘 다 트래픽을 분산시키는 역할을 하지만, 목적과 기능이 다릅니다.

**Load Balancer**는 **같은 서비스**의 여러 인스턴스에 트래픽을 균등하게 분산시키는 것이 주목적입니다. 예를 들어 주문 서비스가 3대 있으면, 요청을 3대에 골고루 나눠줍니다. 주로 L4(Transport Layer) 또는 L7(Application Layer) 수준에서 동작합니다.

**API Gateway**는 트래픽 분산뿐만 아니라 **다양한 서비스로 요청을 라우팅**하고, 인증, 캐싱, 속도 제한 같은 **비즈니스 로직**도 처리합니다. 주로 L7(Application Layer)에서 동작하며, HTTP 요청의 경로나 헤더를 분석해서 어느 서비스로 보낼지 결정합니다.

실제로는 둘을 함께 사용하기도 합니다:
```
[클라이언트] → [Load Balancer] → [API Gateway 1, 2, 3] → [각 마이크로서비스]
```

API Gateway 앞에 Load Balancer를 두어서 Gateway 자체의 가용성과 확장성을 높이는 구조입니다.

---

## 10. Scale Up(수직 확장)과 Scale Out(수평 확장)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.01)

**답변**

서비스 사용자가 급증해서 서버가 부족할 때, 크게 두 가지 방식으로 확장할 수 있습니다.

**Scale Up (수직 확장)**은 기존 서버의 **하드웨어 성능을 높이는** 방식입니다. CPU를 더 좋은 것으로 교체하거나, RAM을 추가하거나, SSD 용량을 늘리는 식이죠. 하나의 서버가 더 강력해지는 개념입니다.

**Scale Out (수평 확장)**은 **서버의 개수를 늘리는** 방식입니다. 동일한 사양의 서버를 여러 대 추가하고, 로드밸런서를 통해 트래픽을 분산시킵니다.

| 구분 | Scale Up (수직 확장) | Scale Out (수평 확장) |
|------|---------------------|----------------------|
| 방식 | 서버 성능 향상 | 서버 개수 증가 |
| 장점 | 구조가 단순, 관리 용이 | 무중단 확장 가능, 장애 대응에 유리 |
| 단점 | 하드웨어 한계 존재, 확장 시 다운타임 발생 | 구조 복잡, 데이터 동기화 이슈 |
| 비용 | 고성능일수록 기하급수적 증가 | 선형적 증가 |
| 예시 | DB 서버 성능 강화 | 웹 서버 다중화 |

**실무에서는 두 방식을 혼합해서 사용**하는 경우가 많습니다. 예를 들어 웹 서버는 Scale Out으로 여러 대를 두고, 데이터베이스는 Scale Up으로 고성능 서버를 사용하는 방식으로 사용할 수 있습니다. 상태를 가지지 않는(Stateless) 서버는 Scale Out이 쉽고, 상태를 가지는(Stateful) 서버는 Scale Up이 더 단순하기 때문입니다.

---

## **예상 꼬리질문**

**Q1. Scale Out 환경에서 세션 관리는 어떻게 하나요?**

A. 서버가 여러 대면 사용자의 세션 정보를 어디에 저장할지가 문제가 됩니다. 세 가지 방법이 있습니다.

첫째, **Sticky Session**입니다. 로드밸런서가 특정 사용자를 항상 같은 서버로 보내는 방식이에요. 구현이 간단하지만, 해당 서버가 죽으면 세션이 사라지고 부하 분산이 불균형해질 수 있습니다.

둘째, **Session Clustering**입니다. 서버들끼리 세션 정보를 복제해서 공유하는 방식이에요. 서버 간 동기화 오버헤드가 발생합니다.

셋째, **외부 세션 저장소**입니다. Redis나 Memcached 같은 별도 저장소에 세션을 보관하는 방식이에요. 서버가 Stateless해지고 확장이 자유로워져서, 현재 가장 많이 사용되는 방식입니다.


**Q2. 왜 데이터베이스는 Scale Out이 어렵다고 하나요?**

A. 데이터베이스는 **데이터 정합성** 때문에 Scale Out이 까다롭습니다.

웹 서버는 요청을 처리하고 끝이지만, DB는 여러 서버에 데이터가 나뉘어 있을 때 문제가 생겨요. 예를 들어 A 서버에서 잔액을 수정하는 동시에 B 서버에서 같은 잔액을 조회하면, 어떤 값이 맞는 건지 보장하기 어렵습니다.

그래서 DB를 Scale Out할 때는 **샤딩**(데이터를 분할 저장)이나 **레플리케이션**(읽기 전용 복제본 생성) 같은 전략을 사용하는데, 이 과정에서 트랜잭션 처리, 데이터 동기화, JOIN 쿼리 처리 등 복잡한 문제들이 따라옵니다.

---

## 11. Stateful과 Stateless의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.02)

**답변**

**Stateful(상태 유지)**은 서버가 클라이언트의 **이전 상태를 기억하고 있는** 방식입니다. 클라이언트가 이전에 어떤 요청을 보냈는지, 로그인은 했는지 등의 정보를 서버가 가지고 있습니다.

**Stateless(무상태)**는 서버가 클라이언트의 **상태를 저장하지 않는** 방식입니다. 매 요청이 독립적이고, 필요한 정보는 클라이언트가 요청할 때마다 함께 보내야 합니다.

| 구분 | Stateful | Stateless |
|------|----------|-----------|
| 상태 저장 | 서버가 저장 | 클라이언트가 매번 전달 |
| 서버 확장 | 어려움 (세션 동기화 필요) | 쉬움 (어떤 서버든 처리 가능) |
| 장애 대응 | 서버 죽으면 상태 유실 | 서버 죽어도 영향 없음 |
| 예시 | TCP, 세션 기반 인증 | HTTP, JWT 토큰 인증 |

**HTTP는 기본적으로 Stateless 프로토콜**입니다. 그런데 로그인 유지 같은 기능이 필요하잖아요? 그래서 쿠키, 세션, 토큰 같은 방법으로 Stateless한 HTTP 위에서 상태를 관리합니다.

실무에서는 **서버를 최대한 Stateless하게 설계**하는 것이 좋습니다. 서버가 상태를 갖지 않으면 Scale Out이 자유롭고, 특정 서버에 장애가 생겨도 다른 서버가 바로 대신 처리할 수 있거든요.

---

## **예상 꼬리질문**

**Q1. 세션 기반 인증과 토큰(JWT) 기반 인증의 차이는 무엇인가요?**

A. **세션 기반 인증**은 Stateful 방식입니다. 사용자가 로그인하면 서버가 세션 ID를 생성해서 서버 메모리(또는 DB)에 저장하고, 클라이언트에게는 세션 ID만 쿠키로 전달해요. 이후 요청마다 서버는 세션 ID로 저장된 정보를 조회합니다.

**토큰(JWT) 기반 인증**은 Stateless 방식입니다. 로그인하면 서버가 사용자 정보를 담은 토큰을 발급하고, 서버는 아무것도 저장하지 않아요. 클라이언트가 매 요청마다 토큰을 보내면, 서버는 토큰 자체를 검증해서 사용자를 확인합니다.

토큰 방식은 서버가 상태를 저장하지 않아 Scale Out에 유리하지만, 토큰 탈취 시 만료 전까지 무효화하기 어렵다는 단점이 있습니다.


**Q2. TCP는 Stateful인데 HTTP는 왜 Stateless인가요?**

A. **TCP**는 연결 지향 프로토콜로, 3-way handshake로 연결을 맺고 연결 상태를 유지합니다. 누가 연결되어 있는지, 어디까지 데이터를 받았는지 등의 상태를 추적해야 신뢰성 있는 전송이 가능하거든요.

**HTTP**는 TCP 위에서 동작하지만, 애플리케이션 레벨에서는 Stateless로 설계됐어요. 요청-응답이 끝나면 연결에 대한 정보를 기억하지 않습니다. 초기 웹은 단순히 문서를 요청하고 받는 용도였기 때문에, 상태를 유지할 필요가 없었고 서버 부담을 줄이기 위해 Stateless로 만들어졌습니다.

참고로 HTTP/1.1의 Keep-Alive나 HTTP/2의 멀티플렉싱은 TCP 연결을 재사용하는 것이지, HTTP 자체가 Stateful해지는 건 아닙니다.

---

## 12. OAuth 2.0이 무엇이고, 어떤 상황에서 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.05)

**답변**

OAuth 2.0은 **권한 부여를 안전하게 위임하기 위한 표준 프로토콜**입니다. 쉽게 말하면, 사용자가 자신의 비밀번호를 직접 공유하지 않고도 다른 서비스에게 특정 권한을 위임할 수 있게 해줍니다.

예를 들어 "구글로 로그인" 버튼을 누르면, 우리 서비스가 구글에 직접 비밀번호를 받는 게 아니라 구글이 발급한 **액세스 토큰**을 통해 사용자 정보에 접근합니다. 
사용자는 구글에서 동의 화면을 보고 권한을 승인합니다.

**사용 상황**
- 소셜 로그인 (구글, 카카오, 네이버 로그인)
- 서드파티 앱에서 사용자 데이터 접근 (캘린더 앱이 구글 캘린더에 접근)
- API 접근 권한 관리


## **예상 꼬리질문**

**Q1. OAuth 2.0에서 인증(Authentication)과 인가(Authorization)의 차이는 무엇인가요?**

A. 인증은 누구인지를 확인하는 것이고, 인가는 해도 되는지를 확인하는 것입니다.

OAuth 2.0은 엄밀히 말하면 인가(Authorization) 프로토콜입니다. "이 앱이 내 구글 드라이브를 읽을 수 있는 권한이 있는가?"를 다루는 것입니다.
인증 기능을 추가하려면 OAuth 2.0 위에 OpenID Connect(OIDC)를 함께 사용합니다. OIDC는 ID 토큰을 통해 사용자가 누구인지까지 확인해줍니다.


**Q2. Access Token과 Refresh Token의 차이는 무엇인가요?**

A. **Access Token**은 실제로 API에 접근할 때 사용하는 토큰입니다. 보안을 위해 유효기간이 짧습니다 (보통 몇 분 ~ 몇 시간).

**Refresh Token**은 Access Token이 만료됐을 때 새로운 Access Token을 발급받기 위한 토큰입니다. 유효기간이 길고(며칠 ~ 몇 주), 서버에 안전하게 저장됩니다.

이렇게 분리하는 이유는 Access Token이 탈취되더라도 금방 만료되어 피해를 최소화할 수 있기 때문입니다.

---

## 13. WebSocket이란 무엇이고, 기존 HTTP 통신과 어떤 차이가 있나요? 어떤 상황에서 WebSocket을 사용하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.11)

**답변**

WebSocket은 **클라이언트와 서버 간 양방향 실시간 통신**을 가능하게 하는 프로토콜입니다. 한 번 연결을 맺으면 끊기 전까지 양쪽에서 자유롭게 데이터를 주고받을 수 있습니다.

| 구분 | HTTP | WebSocket |
|------|------|-----------|
| 통신 방향 | 단방향 (요청-응답) | 양방향 |
| 연결 방식 | 요청마다 연결/종료 | 한 번 연결 후 유지 |
| 오버헤드 | 매 요청마다 헤더 포함 | 초기 핸드셰이크 후 최소 오버헤드 |
| 서버 → 클라이언트 | 클라이언트 요청 필요 | 서버가 먼저 데이터 전송 가능 |

**사용 상황**
- 실시간 채팅
- 주식/코인 시세 업데이트
- 실시간 알림
- 멀티플레이어 게임
- 협업 도구 (Google Docs 동시 편집)
등 실시간 양방향 통신이 필요한 상황에서 주로 사용됩니다.

## **예상 꼬리질문**

**Q1. WebSocket 연결은 어떻게 맺어지나요?**

A. WebSocket은 **HTTP 핸드셰이크로 시작**합니다.

1. 클라이언트가 HTTP 요청에 `Upgrade: websocket` 헤더를 포함해 전송
2. 서버가 `101 Switching Protocols` 응답으로 프로토콜 전환 승인
3. 이후부터는 HTTP가 아닌 WebSocket 프로토콜로 양방향 통신

이렇게 HTTP로 시작하기 때문에 기존 웹 인프라(방화벽, 프록시)를 그대로 통과할 수 있습니다.

**Q2. WebSocket의 단점은 무엇인가요?**

A. **연결 유지 비용**: 서버가 모든 클라이언트와 연결을 유지해야 해서 동시 접속자가 많으면 리소스 부담이 큽니다.

**상태 관리 복잡**: HTTP는 Stateless라서 어떤 서버든 요청을 처리할 수 있지만, WebSocket은 특정 서버와 연결이 유지되므로 Scale Out 시 세션 관리가 복잡합니다. Redis Pub/Sub 같은 메시지 브로커로 서버 간 동기화가 필요합니다.

**연결 끊김 처리**: 네트워크 불안정으로 연결이 끊길 수 있어 재연결 로직, 하트비트(ping/pong) 구현이 필요합니다.

---

## 14. TCP와 UDP의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.11)

**답변**

TCP와 UDP는 전송 계층에서 "데이터를 어떻게 전달할 것인가"를 정의한 프로토콜입니다.
TCP는 **연결형 프로토콜**이고, UDP는 **비연결형 프로토콜**입니다.

TCP는 데이터를 보내기 전에 3-way handshake로 연결을 먼저 수립합니다. 패킷 순서를 보장하고, 손실된 패킷은 재전송해서 신뢰성을 확보합니다.
대신 이런 과정들 때문에 속도가 느립니다. HTTP, 파일 전송, 이메일처럼 데이터가 정확히 도착해야 하는 경우에 사용합니다.

UDP는 연결 과정 없이 바로 데이터를 보냅니다. 순서 보장도, 재전송도 없어서 신뢰성은 떨어지지만 그만큼 빠릅니다. 
실시간 게임, 영상 스트리밍, 음성 통화처럼 약간의 손실보다 속도가 더 중요한 경우에 사용합니다.


## **예상 꼬리질문**

**Q1. 3-way handshake가 무엇인가요?**

A. TCP에서 연결을 수립하는 과정입니다. 클라이언트가 서버에게 "연결해도 돼?"라고 SYN을 보내면, 서버가 "응, 나도 연결할게"라고 SYN+ACK를 보내고, 클라이언트가 "확인했어"라고 ACK를 보내면 연결이 완료됩니다. 이렇게 세 번 주고받아서 3-way handshake라고 부릅니다.

이 과정을 통해 양쪽 모두 데이터를 주고받을 준비가 됐는지 확인하고, 초기 순서 번호를 교환합니다.

**Q2. 연결을 끊을 때도 handshake가 있나요?**

A. 네, 연결 종료 시에는 **4-way handshake**를 사용합니다. 한쪽이 "나 끊을게"라고 FIN을 보내면, 상대가 "알겠어"라고 ACK를 보냅니다. 그 다음 상대도 "나도 끊을게"라고 FIN을 보내고, "알겠어"라고 ACK를 보내면 종료됩니다.

3-way가 아니라 4-way인 이유는, 한쪽이 종료 요청을 해도 상대방은 아직 보낼 데이터가 남아있을 수 있기 때문입니다. 그래서 각자 독립적으로 종료 의사를 밝히는 겁니다.


**Q3. UDP는 신뢰성이 없는데 왜 사용하나요?**

A. 상황에 따라 **신뢰성보다 속도가 더 중요할 때**가 있기 때문입니다.

예를 들어 영상 통화 중에 패킷 하나가 손실됐다고 재전송을 기다리면 화면이 끊기거나 지연됩니다. 
차라리 그 프레임 하나 건너뛰고 다음 프레임을 보여주는 게 사용자 경험에 더 좋습니다. 
실시간 게임도 마찬가지로, 0.1초 전 위치 정보를 재전송받는 것보다 최신 위치를 빨리 받는 게 중요합니다.

필요하면 애플리케이션 레벨에서 신뢰성을 구현하기도 합니다.

**Q4. HTTP/3는 UDP 기반이라던데, 왜 그런가요?**

A. HTTP/3는 **QUIC**이라는 프로토콜 위에서 동작하는데, QUIC이 UDP 기반입니다.

TCP는 하나의 패킷이 손실되면 뒤따르는 모든 패킷이 기다려야 하는 **Head-of-Line Blocking** 문제가 있습니다. 
QUIC은 UDP 위에서 자체적으로 신뢰성과 순서 보장을 구현하면서, 스트림별로 독립적으로 처리해서 이 문제를 해결했습니다. 또한 연결 수립도 더 빨라서 성능이 향상됩니다.

---

**피드백**

좋은 시작이에요! 다만 몇 가지 보완하면 더 좋아요.

1. **S는 "Secure"의 S예요** (Security 아니고요!)
2. **"어떻게" 안전한지**를 좀 더 구체적으로 설명하면 좋아요
   - 암호화: 데이터를 중간에 가로채도 읽을 수 없음
   - 인증서: 내가 접속한 서버가 진짜 그 서버인지 확인
   - 무결성: 데이터가 중간에 변조되지 않았는지 확인
3. 포트 번호 차이도 언급하면 좋아요 (HTTP는 80, HTTPS는 443)

---

## 15. HTTP와 HTTPS의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.18)

**답변**

HTTPS는 HTTP에 **보안 계층(TLS/SSL)**을 추가한 프로토콜입니다. S는 Secure의 약자예요.

HTTP는 데이터를 평문으로 전송하기 때문에, 누군가 중간에서 패킷을 가로채면 내용을 그대로 볼 수 있습니다. HTTPS는 TLS를 통해 데이터를 암호화해서 전송하기 때문에 가로채도 내용을 알 수 없습니다.

HTTPS가 제공하는 보안 기능은 크게 세 가지입니다. 첫째, **암호화**로 데이터를 읽을 수 없게 합니다. 둘째, **인증**으로 내가 접속한 서버가 진짜 그 서버인지 인증서를 통해 확인합니다. 셋째, **무결성**으로 데이터가 중간에 변조되지 않았음을 보장합니다.

기본 포트는 HTTP가 80번, HTTPS가 443번입니다.

## **예상 꼬리질문**

**Q1. TLS와 SSL의 차이는 무엇인가요?**

A. SSL은 원래 Netscape에서 만든 암호화 프로토콜인데, 보안 취약점이 발견되면서 TLS로 대체되었습니다. TLS는 SSL의 후속 버전이라고 보면 됩니다. 현재 SSL은 더 이상 사용되지 않고, TLS 1.2나 1.3을 사용합니다. 다만 관례적으로 "SSL 인증서"라는 표현이 아직 많이 쓰이고 있어요.


**Q2. HTTPS는 어떻게 암호화하나요?**

A. HTTPS는 **대칭키와 비대칭키 암호화를 함께 사용**합니다.

처음 연결할 때는 비대칭키(공개키/개인키)로 안전하게 대칭키를 교환합니다. 비대칭키는 안전하지만 느리거든요. 대칭키를 교환한 이후에는 그 대칭키로 실제 데이터를 암호화합니다. 대칭키는 빠르지만 키를 안전하게 전달하는 게 문제인데, 비대칭키가 그 문제를 해결해주는 겁니다.

이렇게 두 방식의 장점을 조합해서 보안과 성능을 모두 잡습니다.


**Q3. HTTPS를 사용하면 성능이 떨어지나요?**

A. 예전에는 암호화/복호화 과정 때문에 오버헤드가 있었는데, 지금은 거의 차이가 없습니다.

하드웨어 성능이 좋아지고, TLS 1.3에서는 핸드셰이크 과정이 간소화되어서 연결 속도도 빨라졌습니다. 오히려 HTTP/2와 HTTP/3는 HTTPS에서만 동작하는 경우가 많아서, HTTPS가 더 빠를 수도 있어요.

현재는 보안뿐 아니라 SEO, 브라우저 경고 방지 측면에서도 HTTPS가 필수입니다.

---

## 16. 세션(Session)과 쿠키(Cookie)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.29)

**답변**

둘 다 로그인 상태 같은 정보를 유지하기 위해 사용하는데, 가장 큰 차이는 저장 위치입니다.

쿠키는 브라우저에 저장됩니다. 서버가 Set-Cookie로 전달하면 이후 요청마다 브라우저가 자동으로 쿠키를 보냅니다. 근데 클라이언트에 저장되다 보니 사용자가 볼 수 있어서 민감한 정보를 담으면 안 됩니다.

세션은 서버에 저장됩니다. 서버가 사용자 정보를 세션에 저장하고, 클라이언트에게는 세션 ID만 쿠키로 줍니다. 요청이 오면 세션 ID로 서버에서 정보를 찾습니다. 
민감한 정보가 서버에 있어서 보안에는 유리한데, 사용자가 많아지면 서버 메모리 부담이 커집니다.


## **예상 꼬리질문**

**Q1. JWT와 세션/쿠키 방식의 차이점은 무엇인가요?**

A. 세션은 서버가 정보를 저장하고 관리하는 Stateful 방식이고, JWT는 서버가 토큰만 발급하고 저장하지 않는 Stateless 방식입니다.
세션은 서버에서 바로 무효화할 수 있어서 로그아웃 처리가 확실한데, 서버 확장이 어렵습니다. 

JWT는 서버 부담이 적고 확장이 쉬운데, 토큰이 탈취되면 만료 전까지 막기가 어렵습니다. 
그래서 보통 만료 시간을 짧게 하고 Refresh Token을 같이 씁니다.


**Q2. 세션 방식에서 서버를 여러 대로 확장하면 어떤 문제가 생기나요?**

A. 사용자가 A 서버에서 로그인했는데 다음 요청이 B 서버로 가면, B 서버에는 세션 정보가 없어서 로그인이 풀린 것처럼 됩니다.

이 문제를 해결하는 방법은 세 가지가 있습니다. 첫째, **Sticky Session**으로 같은 사용자는 항상 같은 서버로 보냅니다. 둘째, **세션 클러스터링**으로 서버 간에 세션을 공유합니다. 셋째, **세션 스토리지 분리**로 Redis 같은 외부 저장소에 세션을 저장해서 모든 서버가 접근하게 합니다. 실무에서는 Redis를 많이 사용합니다.


**Q3. 쿠키에 보안 옵션에는 어떤 것들이 있나요?**

A. 주요 옵션이 네 가지 있습니다.

**HttpOnly**는 JavaScript에서 쿠키에 접근하지 못하게 막습니다. XSS 공격으로 쿠키를 탈취하는 걸 방지합니다.

**Secure**는 HTTPS 연결에서만 쿠키를 전송합니다. 네트워크에서 쿠키가 노출되는 걸 막습니다.

**SameSite**는 다른 사이트에서 요청할 때 쿠키 전송을 제한합니다. CSRF 공격을 방지합니다.

**Max-Age/Expires**는 쿠키 만료 시간을 설정합니다. 설정하지 않으면 브라우저 종료 시 삭제됩니다.

---

## 17. DNS(Domain Name System)란 무엇이며, 왜 필요한가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2026.01.09)

**답변**

DNS는 도메인 이름을 IP 주소로 변환해주는 시스템입니다. 컴퓨터끼리 통신하려면 IP 주소가 필요한데, 사람이 IP 주소를 다 기억하기는 어렵습니다. 
그래서 `google.com`처럼 기억하기 쉬운 도메인 이름을 사용하고, DNS가 이걸 실제 IP 주소로 변환해줍니다.

전화번호부에서 이름으로 번호를 찾는 것처럼, DNS는 도메인 이름으로 IP 주소를 찾아주는 역할입니다. 덕분에 사용자는 IP 주소를 몰라도 도메인 이름만 알면 원하는 사이트에 접속할 수 있습니다.


## **예상 꼬리질문**

**Q1. DNS 조회 과정을 설명해주세요.**

A. 브라우저에 `google.com`을 입력하면, 먼저 로컬 캐시에 저장된 IP가 있는지 확인합니다. 없으면 DNS 서버에 질의를 보냅니다.

DNS 서버도 계층 구조로 되어 있어서, 로컬 DNS 서버 → 루트 DNS 서버 → `.com` 담당 DNS 서버 → `google.com` 담당 DNS 서버 순서로 물어봅니다. 
최종적으로 IP 주소를 받으면 이걸 캐시에 저장해두고, 그 IP로 서버에 연결합니다.


**Q2. DNS 캐싱은 왜 하나요?**

A. 매번 DNS 서버에 질의하면 시간이 오래 걸리니까, 한 번 조회한 결과를 저장해두고 재사용합니다. 브라우저, 운영체제, 로컬 DNS 서버 각각에서 캐싱을 합니다.

캐시에는 TTL(Time To Live)이 있어서 일정 시간이 지나면 만료되고 다시 조회합니다. 이렇게 해야 IP 주소가 바뀌었을 때 반영될 수 있습니다.


**Q3. DNS가 UDP를 사용하는 이유는 뭔가요?**

A. DNS 질의는 보통 작은 데이터를 빠르게 주고받는 거라서 TCP보다 UDP가 적합합니다. TCP는 연결을 맺는 데만 3-way handshake가 필요한데, 간단한 질의 하나에 그 오버헤드는 낭비이기 때문입니다.

다만 응답 크기가 크거나 영역 전송처럼 신뢰성이 필요한 경우에는 TCP를 사용하기도 합니다.

---
