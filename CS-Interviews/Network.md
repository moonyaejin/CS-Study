## 📚 질문 목록
1. [RESTful API란? REST의 특징](#1-restful-api란-무엇인가요-rest의-특징은-무엇인지-restful하게-api를-설계한다는-것은-어떤-의미인지-설명해주세요)
2. [동기(Sync) 방식과 비동기(Async) 방식의 차이점은 무엇인가요?](#2-동기sync-방식과-비동기async-방식의-차이점은-무엇인가요)
3. [웹 서버(Web Server)와 WAS(Web Application Server)의 차이점은 무엇인가요?](#3-웹-서버web-server와-wasweb-application-server의-차이점은-무엇인가요)
4. [OSI 7계층 모델에 대해 아는 대로 설명해주세요.](#4-osi-7계층-모델에-대해-아는-대로-설명해주세요)

## 1. RESTful API란 무엇인가요? REST의 특징은 무엇인지, 'RESTful하게 API를 설계한다'는 것은 어떤 의미인지 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.21)

**답변**

REST는 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일입니다. RESTful API는 REST 원칙을 따르는 API를 말합니다.

**REST의 주요 특징**
- **무상태성(Stateless)**: 서버가 클라이언트의 상태를 저장하지 않습니다. 각 요청은 독립적이며 필요한 모든 정보를 포함해야 합니다.
- **자원 중심 설계**: URL이 자원(Resource)을 나타냅니다. 예: `/users`, `/posts`
- **HTTP 메서드 활용**: GET(조회), POST(생성), PUT(전체 수정), PATCH(부분 수정), DELETE(삭제)를 명확히 구분해서 사용합니다.
- **계층화된 시스템**: 클라이언트는 서버의 구조를 알 필요 없이 API만으로 통신합니다.

**RESTful하게 API를 설계한다는 의미**

URL은 행위가 아닌 자원을 표현하고, HTTP 메서드로 행위를 나타내는 것입니다.

- 좋은 예: `GET /users/123`, `DELETE /users/123`
- 나쁜 예: `GET /getUser?id=123`, `POST /deleteUser`

또한 일관된 규칙을 사용하고(예: 복수형 명사 사용), 적절한 HTTP 상태 코드를 반환하며(200, 201, 404, 500 등), 명확하고 예측 가능한 구조를 유지하는 것을 의미합니다.


## **예상 꼬리질문**

**Q1. REST와 RESTful의 차이는 무엇인가요?**

A. REST는 아키텍처 원칙 그 자체를 말하고, RESTful은 REST 원칙을 잘 따르는 시스템을 표현하는 형용사입니다. 

예를 들어 "이 API는 RESTful하다"는 말은 REST의 원칙들(무상태성, 자원 중심 설계 등)을 잘 지켜서 설계되었다는 의미입니다. 반대로 REST 원칙을 일부만 따르거나 지키지 않으면 "RESTful하지 않다"고 표현합니다.


**Q2. RESTful API의 단점이나 한계는 무엇인가요?**

A. REST는 표준이 명확하지 않아서 개발자마다 해석이 다를 수 있습니다. 예를 들어 URL 설계 규칙이 팀마다 조금씩 다를 수 있습니다.

또한 복잡한 쿼리나 여러 자원을 한 번에 요청할 때 비효율적입니다. 예를 들어 사용자 정보와 그 사용자의 게시글, 댓글을 함께 가져오려면 여러 번 API를 호출해야 할 수 있습니다(Over-fetching/Under-fetching 문제).

이런 한계 때문에 최근에는 GraphQL 같은 대안 기술도 함께 사용되고 있습니다. GraphQL은 클라이언트가 필요한 데이터를 정확히 요청할 수 있어서 REST의 단점을 보완합니다.

---

## 2. 동기(Sync) 방식과 비동기(Async) 방식의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.03)

**답변**

동기는 작업들이 순차적으로 실행되는 방식으로, 한 작업이 시작되면 해당 작업이 완료될 때까지 다음 작업이 기다려야 합니다. 코드의 흐름이 직관적이고 이해하기 쉬우며 디버깅이 용이하다는 장점이 있지만, 작업이 오래 걸리면 전체 프로그램이 멈춰서 사용자 경험이 나빠질 수 있다는 단점이 있습니다. 

비동기는 작업의 완료 여부를 기다리지 않고 다른 작업을 동시에 실행할 수 있는 방식을 의미합니다. I/O 작업 중에도 다른 작업을 처리할 수 있어 효율적이며, 많은 동시 요청을 적은 리소스로 처리 가능하다는 장점이 있지만, 코드가 복잡해지고 실행 순서를 예측하기 어려워 디버깅이 어려울 수 있다는 단점이 있습니다.

외부 API를 호출하는 동안 다른 작업을 할 수 있다면 비동기가 효율적이지만, 단순한 CRUD 작업은 동기 방식이 코드가 더 명확합니다.

## **예상 꼬리질문**

**Q1.  스프링에서는 비동기 처리를 어떻게 구현하나요?**
A. 스프링은 여러 방식으로 비동기 처리를 지원합니다.
1. @Async 어노테이션 : 메서드에 붙이면 별도 스레드에서 비동기로 실행됩니다. @EnableAsync 설정이 필요합니다.
2. CompletableFuture: 비동기 작업의 결과를 처리하고 조합할 수 있습니다.
3. SpringWebFlux: Reactor 기반의 완전한 비동기/논플로킹 프레임워크로, 대량의 동시 요청 처리에 적합합니다.

전통적인 Spring MVC는 요청당 하나의 스레드를 할당하는 동기 방식이지만, WebFlux는 적은 스레드로 많은 요청을 처리할 수 있습니다.

---

## 3. 웹 서버(Web Server)와 WAS(Web Application Server)의 차이점은 무엇인가요? 
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.05)

**답변**

웹 서버와 WAS는 둘 다 웹 서비스를 제공하는 서버인데, 무엇을 처리하느냐에 따라 역할이 다릅니다.

**웹 서버**는 **정적 콘텐츠**를 처리합니다. 이미 만들어진 HTML 파일, CSS, JavaScript, 이미지 같은 고정된 파일들을 그대로 사용자에게 전달해주는 역할을 합니다. 대표적으로 Nginx, Apache가 있습니다.

**WAS**는 **동적 콘텐츠**를 처리합니다. 사용자 요청에 따라 프로그램을 실행하고, 데이터베이스를 조회하고, 비즈니스 로직을 처리해서 그때그때 결과를 만들어냅니다. 예를 들어 로그인, 주문 내역 조회, 결제 처리 같은 복잡한 작업을 수행합니다. Tomcat, Node.js, Django 등이 WAS입니다.

웹 서버와 WAS는 함께 사용합니다. 웹 서버가 먼저 요청을 받아 정적 파일을 바로 처리하고, 동적 처리가 필요한 요청만 WAS로 넘겨주는 방식입니다. 
웹 서버를 앞에 두면 정적 파일 처리가 빨라지고, WAS의 부담을 줄일 수 있어서 효율적입니다.


## **예상 꼬리질문**

**Q1. 정적 콘텐츠와 동적 콘텐츠를 구분하는 기준이 뭔가요?**

A. 미리 만들어져 있느냐, 그때그때 만드느냐의 차이입니다.

정적 콘텐츠는 서버에 파일이 그대로 저장되어 있어서, 누가 언제 요청하든 같은 내용을 보여줍니다.

동적 콘텐츠는 요청할 때마다 프로그램이 실행되어 결과가 달라집니다. 데이터베이스 조회가 필요하거나, 사용자 입력에 따라 계산이 필요한 경우가 대부분 동적 콘텐츠입니다.


**Q2. 리버스 프록시(Reverse Proxy)는 웹 서버와 어떤 관계인가요?**

A. 리버스 프록시는 웹 서버가 수행하는 역할 중 하나입니다.

일반적으로 Nginx 같은 웹 서버를 리버스 프록시로 사용해서, 클라이언트 요청을 받아 뒤쪽의 WAS들에게 전달하고 응답을 다시 클라이언트에게 돌려주는 중개자 역할을 합니다.

여러 WAS로 요청을 분산시킬 수 있고(로드밸런싱), 특정 WAS가 죽어도 다른 WAS로 요청을 돌릴 수 있으며(무중단 배포), WAS의 실제 주소를 숨겨서 보안도 강화되는 장점이 있습니다. 
실제 서비스에서 "Nginx + Tomcat" 조합을 많이 쓰는 이유가 이런 리버스 프록시 기능 때문입니다.

---

## 4. OSI 7계층 모델에 대해 아는 대로 설명해주세요.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.06)

**답변**

OSI 7계층은 **네트워크 통신 과정을 7단계로 나눈 표준 모델**입니다. 통신이 일어나는 과정을 단계별로 나눠서 각 계층이 독립적인 역할을 수행하도록 설계되었습니다. 문제가 생기면 어느 계층에서 발생했는지 파악하기 쉽고, 특정 계층만 교체하거나 업그레이드할 수 있어서 유지보수가 편리합니다.

**7. Application (응용 계층)**
사용자가 실제로 사용하는 애플리케이션이 동작하는 계층입니다. HTTP, FTP, SMTP, DNS 같은 프로토콜이 여기서 작동하며, 웹 브라우저나 이메일 클라이언트가 이 계층에서 동작합니다.

**6. Presentation (표현 계층)**
데이터의 형식을 변환하고 암호화/복호화를 담당합니다. 예를 들어 JPEG 이미지를 압축하거나, HTTPS의 SSL/TLS 암호화가 이 계층에서 이루어집니다. 서로 다른 시스템 간에 데이터를 이해할 수 있도록 번역하는 역할을 합니다.

**5. Session (세션 계층)**
통신 연결을 관리합니다. 데이터 교환의 시작과 종료를 제어하고, 연결이 끊어졌을 때 복구하는 역할을 합니다.

**4. Transport (전송 계층)**
데이터를 신뢰성 있게 전달하는 역할입니다. TCP와 UDP가 여기서 동작하며, 포트 번호로 어떤 애플리케이션에게 데이터를 전달할지 결정합니다. TCP는 데이터가 순서대로 도착하는지 확인하고, 손실되면 재전송합니다.

**3. Network (네트워크 계층)**
데이터를 목적지까지 전달하는 경로를 찾습니다. IP 주소를 사용해서 라우팅을 수행하며, 라우터가 이 계층에서 동작합니다. 여러 네트워크를 거쳐서 최종 목적지까지 패킷을 전달하는 역할을 합니다.

**2. Data Link (데이터 링크 계층)**
같은 네트워크 내에서 직접 연결된 기기 간의 데이터 전송을 담당합니다. MAC 주소를 사용하며, 이더넷 프레임을 만들고 오류를 검출합니다. 스위치가 이 계층에서 동작합니다.

**1. Physical (물리 계층)**
실제 물리적인 연결과 전기 신호를 다룹니다. 케이블, 전파, 광섬유 같은 물리적 매체를 통해 비트(0과 1)를 전송합니다. 허브나 리피터 같은 장비가 이 계층에서 동작합니다.


## **예상 꼬리질문**

**Q1. 실제로는 TCP/IP 모델을 더 많이 사용하는데, OSI 7계층과 어떻게 다른가요?**

A. TCP/IP 모델은 OSI 7계층을 4계층으로 단순화한 **실용적인 모델**입니다.

OSI는 이론적/표준적 모델이고, TCP/IP는 실제 인터넷에서 사용되는 모델입니다. TCP/IP는 Application(응용+표현+세션), Transport(전송), Internet(네트워크), Network Access(데이터링크+물리) 이렇게 4계층으로 구성됩니다.

개발자들은 OSI 7계층으로 개념을 이해하고, 실제 구현할 때는 TCP/IP 모델을 사용하는 경우가 많습니다. OSI는 문제를 진단하거나 설명할 때 유용한 참조 모델 역할을 합니다.


**Q2. 3-way handshake는 OSI 7계층 중 어느 계층에서 일어나나요?**

A. Transport 계층(4계층)에서 일어납니다.

3-way handshake는 TCP 연결을 수립하는 과정인데, TCP가 Transport 계층의 프로토콜이기 때문입니다. SYN, SYN-ACK, ACK 패킷을 주고받으면서 신뢰성 있는 연결을 만듭니다.
