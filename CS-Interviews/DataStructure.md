## 📚 질문 목록

1. [배열(Array)과 연결 리스트(LinkedList)의 차이점은 무엇인가요? 데이터를 저장하는 방식이 어떻게 다르고, 그로 인해 어떤 장단점이 생기나요?](#1-배열array과-연결-리스트linkedlist의-차이점은-무엇인가요-데이터를-저장하는-방식이-어떻게-다르고-그로-인해-어떤-장단점이-생기나요)
2. [스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?](#2-스택stack과-큐queue의-차이점은-무엇인가요)
3. [해시 테이블은 무엇이고, 왜 그렇게 빠른가요?](#3-해시-테이블은-무엇이고-왜-그렇게-빠른가요)

---

이렇게 작성하시면 됩니다! 나중에 질문이 추가되면 번호를 늘려가면서 목록을 확장하시면 돼요.

## 1. 배열(Array)과 연결 리스트(LinkedList)의 차이점은 무엇인가요? 데이터를 저장하는 방식이 어떻게 다르고, 그로 인해 어떤 장단점이 생기나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.27)

**답변**

배열은 연속된 메모리 공간에 데이터를 순차적으로 저장하는 자료구조입니다. 각 요소는 인덱스를 통해 직접 접근할 수 있어, O(1)의 시간 복잡도로 특정 위치의 데이터를 읽거나 수정할 수 있습니다.
연결 리스트는 노드 단위로 데이터를 저장하며, 각 노드는 데이터와 다음 노드를 가리키는 포인터를 포함합니다. 메모리상에 연속적으로 저장되지 않고 분산되어 저장되며, 포인터로 연결됩니다.

두 자료구조의 가장 큰 차이는 메모리 저장 방식에서 비롯됩니다. 배열은 인덱스를 통해 O(1)로 즉시 접근이 가능하지만, 연결 리스트는 원하는 위치까지 순차적으로 탐색해야 해서 O(n)의 시간이 걸립니다. 
반대로 삽입과 삭제 연산에서는 연결 리스트가 유리한데, 포인터만 변경하면 되므로 O(1)이지만 배열은 중간에 삽입하거나 삭제할 때 나머지 요소들을 모두 이동시켜야 해서 O(n)의 시간이 필요합니다.

메모리 사용 측면에서도 차이가 있는데, 배열은 선언 시 고정된 크기를 미리 할당해야 하지만 연결 리스트는 필요할 때마다 노드를 추가하여 동적으로 크기를 조절할 수 있습니다. 
또한 배열은 연속된 메모리 공간에 저장되어 캐시 지역성이 좋아 실제 성능에서 유리하지만, 연결 리스트는 노드가 메모리에 분산되어 있어 캐시 미스가 빈번하게 발생합니다.

## **예상 꼬리질문**

**Q1. 캐시 지역성(Cache Locality)이 성능에 미치는 영향을 구체적으로 설명해주세요.**

A. 캐시 지역성은 CPU가 메모리에 접근할 때 효율성을 높이는 중요한 개념입니다. CPU는 메모리 접근 속도를 높이기 위해 캐시 메모리를 사용합니다. 
데이터를 읽을 때 해당 데이터뿐만 아니라 인접한 메모리 블록(캐시 라인)을 함께 캐시에 로드합니다.
배열은 연속된 메모리에 저장되므로, 배열[0]을 읽으면 배열[1], [2] 등도 캐시에 함께 로드됩니다. 따라서 순차 접근 시 대부분 캐시 히트가 발생해 매우 빠릅니다.
반면 연결 리스트는 노드가 메모리에 분산되어 있어, 각 노드 접근마다 새로운 메모리 영역을 읽어야 하므로 캐시 미스가 빈번합니다. 실제로 같은 순차 탐색이라도 배열이 연결 리스트보다 5~10배 빠를 수 있습니다.

**Q2. 배열과 연결 리스트는 각각 언제 사용하는 것이 좋을까요?**

A. 배열이 유리한 경우는 인덱스를 통한 빈번한 접근이 필요한 경우입니다. 예를 들어 특정 번호의 학생 정보를 조회하거나, 게임에서 2차원 맵의 특정 좌표를 빠르게 접근해야 할 때 배열이 적합합니다. 
또한 데이터 크기가 고정적이거나 예측 가능한 경우, 그리고 캐시 효율이 중요한 대용량 데이터 처리 시에도 배열이 유리합니다. 
이미지 처리, 행렬 연산, 정렬 알고리즘처럼 연속적인 메모리 접근이 많은 작업에서 배열의 성능이 뛰어납니다.

연결 리스트가 유리한 경우는 빈번한 삽입/삭제가 리스트 앞쪽이나 중간에서 일어나는 경우입니다. 예를 들어 실시간으로 데이터가 추가/제거되는 대기열 시스템이나 히스토리 관리(브라우저의 뒤로가기/앞으로가기) 기능에 적합합니다. 
데이터 크기를 예측할 수 없고 동적으로 크게 변하는 경우, 메모리를 효율적으로 사용해야 하는 상황에서도 연결 리스트가 좋습니다. 음악 플레이리스트, 프로세스 스케줄링, 다항식 계산기처럼 데이터의 추가/삭제가 핵심인 경우에 연결 리스트를 선택합니다.
실무에서는 두 자료구조의 장점을 결합한 Dynamic Array 같은 하이브리드 구조를 많이 사용합니다. 이는 배열의 빠른 접근 속도를 유지하면서도 크기를 동적으로 조절할 수 있어, 대부분의 상황에서 좋은 성능을 보여줍니다.

---

## 2. 스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.30)

**답변**

스택과 큐는 데이터를 저장하고 꺼내는 순서가 다른 선형 자료구조입니다.
스택은 LIFO 구조로, 마지막에 들어간 데이터가 먼저 나옵니다. 마치 접시를 쌓을 때 위에서부터 하나씩 빼내는 것과 같습니다. 데이터를 넣을 때는 push, 꺼낼 때는 pop 연산을 사용합니다.
큐는 FIFO 구조로, 먼저 들어간 데이터가 먼저 나옵니다. 마치 줄을 서서 기다리는 것처럼, 먼저 온 사람이 먼저 나가는 방식입니다. 데이터를 넣을 때는 enqueue, 꺼낼 때는 dequeue 연산을 사용합니다.
두 자료구조 모두 삽입과 삭제 연산이 O(1)의 시간복잡도를 가집니다.

사용 예시
스택: 함수 호출 스택(Call Stack), 브라우저 뒤로가기 기능, 실행 취소(Undo) 기능
큐: 프린터 출력 대기열, 작업 스케줄링, BFS(너비 우선 탐색) 알고리즘

## **예상 꼬리질문**

**Q1. 스택 오버플로우(Stack Overflow)란 무엇인가요?**

A. 스택 오버플로우는 스택 메모리 공간이 가득 차서 더 이상 데이터를 push할 수 없는 상태를 말합니다. 
주로 재귀 함수가 종료 조건 없이 무한히 호출되거나, 너무 깊은 재귀 호출이 발생할 때 일어납니다. 
예를 들어 factorial 함수에서 base case를 빠뜨리면 함수가 계속 호출되면서 스택 오버플로우가 발생할 수 있습니다.

---

## 3. 해시 테이블은 무엇이고, 왜 그렇게 빠른가요?

**답변**
해시 테이블은 **키(key)와 값(value)을 쌍으로 저장**하는 자료구조로, 해시 함수를 사용해 키를 배열의 인덱스로 변환하여 데이터를 저장하고 조회합니다.

해시 테이블이 빠른 이유는 **직접 접근(Direct Access)** 방식을 사용하기 때문입니다. 

일반적인 배열이나 리스트에서 특정 값을 찾으려면 처음부터 끝까지 하나씩 확인해야 하지만(O(n)), 해시 테이블은 해시 함수를 통해 저장 위치를 바로 계산할 수 있어 평균 O(1)의 시간 복잡도로 데이터를 찾을 수 있습니다.

예를 들어, 사용자 ID "user123"으로 회원 정보를 찾는다면:
1. 해시 함수가 "user123"을 숫자 인덱스(예: 7)로 변환
2. 배열의 7번 위치에 바로 접근하여 데이터 조회
3. 중간 과정 없이 한 번에 원하는 데이터에 도달

이러한 특성 덕분에 데이터베이스의 인덱스, 캐시 시스템, 프로그래밍 언어의 딕셔너리/맵 자료구조 등에 널리 활용됩니다.

## **예상 꼬리질문**

**Q1. 해시 충돌(Collision)이란 무엇인가요?**

A. 해시 충돌은 서로 다른 키가 해시 함수를 통해 같은 인덱스로 매핑되는 현상입니다.

예를 들어 "user123"과 "admin456"이라는 서로 다른 키가 모두 인덱스 7로 계산되면, 같은 위치에 두 개의 데이터를 저장해야 하는 문제가 발생합니다.

**해결 방법**

1. **체이닝(Chaining)**: 같은 인덱스에 연결 리스트로 여러 값을 저장합니다. 충돌이 발생하면 해당 위치에 리스트 형태로 데이터를 이어붙이고, 조회 시 리스트를 순회하며 올바른 키를 찾습니다.

2. **개방 주소법(Open Addressing)**: 충돌이 발생하면 다른 빈 공간을 찾아 저장합니다. 선형 탐사, 제곱 탐사, 이중 해싱 등의 방법이 있습니다.

해시 충돌이 많이 발생하면 O(1)의 성능이 보장되지 않고 최악의 경우 O(n)까지 느려질 수 있기 때문에, 좋은 해시 함수 설계와 적절한 테이블 크기 유지가 중요합니다.

---


