## 📚 질문 목록

1. [배열(Array)과 연결 리스트(LinkedList)의 차이점은 무엇인가요?](#1-배열array과-연결-리스트linkedlist의-차이점은-무엇인가요)
2. [스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?](#2-스택stack과-큐queue의-차이점은-무엇인가요)
3. [해시 테이블은 무엇이고, 왜 그렇게 빠른가요?](#3-해시-테이블은-무엇이고-왜-그렇게-빠른가요)

---

## 1. 배열(Array)과 연결 리스트(LinkedList)의 차이점은 무엇인가요? 
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.27/2026.01.07)

**답변**

배열은 연속된 메모리 공간에 데이터를 저장해서 인덱스로 바로 접근할 수 있습니다. 그래서 조회가 O(1)로 빠릅니다. 대신 중간에 삽입하거나 삭제하면 나머지 요소들을 밀거나 당겨야 해서 O(n)이 걸립니다.
연결 리스트는 노드가 포인터로 연결된 구조라서 원하는 위치까지 순차적으로 따라가야 합니다. 조회는 O(n)이지만, 삽입/삭제는 포인터만 바꾸면 되니까 O(1)입니다.
그래서 조회가 빈번하면 배열이 유리하고, 삽입/삭제가 빈번하면 연결 리스트가 유리합니다.

## **예상 꼬리질문**

**Q1. 캐시 지역성(Cache Locality)이 뭔가요?**

A. CPU가 메모리에서 데이터를 읽을 때 해당 데이터만 가져오는 게 아니라 인접한 메모리도 함께 캐시에 올립니다.
배열은 연속된 메모리에 저장되니까 하나를 읽으면 옆에 있는 것들도 같이 캐시에 올라와서 다음 접근이 빠릅니다.

근데 연결 리스트는 노드가 메모리에 흩어져 있어서 매번 새로운 위치를 읽어야 하고, 캐시 미스가 자주 발생합니다. 그래서 같은 순차 탐색이라도 배열이 훨씬 빠를 수 있습니다.

**Q2. 배열과 연결 리스트는 각각 언제 사용하나요?**

A. 배열은 인덱스로 자주 접근하거나 데이터 크기가 어느 정도 예측 가능할 때 씁니다. 이미지 처리나 행렬 연산처럼 연속적으로 데이터를 읽는 작업에 유리합니다.
연결 리스트는 삽입/삭제가 빈번할 때 씁니다. 브라우저 히스토리나 음악 플레이리스트처럼 중간에 추가/제거가 자주 일어나는 경우에 적합합니다.

실무에서는 ArrayList처럼 배열 기반이면서 크기가 동적으로 늘어나는 자료구조를 많이 씁니다.

**Q3. Java에서 ArrayList와 LinkedList 중 뭘 써야 하나요?**
A. 대부분의 경우 ArrayList가 낫습니다. 조회가 빠르고 캐시 지역성도 좋아서 전반적인 성능이 좋습니다. 
LinkedList는 맨 앞에 삽입/삭제가 빈번할 때만 고려하는데, 사실 그런 경우에도 ArrayDeque가 더 빠른 경우가 많습니다. 
그래서 실무에서는 특별한 이유가 없으면 ArrayList를 기본으로 씁니다.

---

## 2. 스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.30/2026.01.13)

**답변**
스택과 큐는 둘 다 데이터를 저장하는 선형 자료구조인데, 데이터를 넣고 빼는 순서가 다릅니다.

스택은 LIFO 방식으로, 나중에 들어간 데이터가 먼저 나옵니다. 함수 호출 스택, 브라우저 뒤로가기, 실행 취소(Undo) 기능에 사용됩니다.

큐는 FIFO 방식으로, 먼저 들어간 데이터가 먼저 나옵니다. 줄을 서서 기다리면 먼저 온 사람이 먼저 처리되는 것과 같습니다. 프린터 출력 대기열, 작업 스케줄링, BFS 알고리즘에 사용됩니다.

삽입과 삭제 연산은 둘 다 O(1)의 시간 복잡도를 가집니다.

## **예상 꼬리질문**

**Q1. 스택 오버플로우(Stack Overflow)란 무엇인가요?**

A. 스택 오버플로우는 스택 메모리 공간이 가득 차서 더 이상 데이터를 push할 수 없는 상태를 말합니다. 
주로 재귀 함수가 종료 조건 없이 무한히 호출되거나, 너무 깊은 재귀 호출이 발생할 때 일어납니다. 
예를 들어 factorial 함수에서 base case를 빠뜨리면 함수가 계속 호출되면서 스택 오버플로우가 발생할 수 있습니다.

**Q2. 덱(Deque)은 무엇인가요?**

A. Double-Ended Queue의 약자로, 양쪽 끝에 삽입과 삭제가 모두 가능한 자료구조입니다.
앞에서 빼면 큐처럼, 뒤에서 빼면 스택처럼 동작해 유연하게 사용 가능합니다.
Java에서는 ArrayDeque가 대표적입니다.

---

## 3. 해시 테이블은 무엇이고, 왜 그렇게 빠른가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2026.01.14)

**답변**

해시 테이블은 key와 value를 쌍으로 저장하는 자료구조입니다. 해시 함수가 key를 받아서 배열의 인덱스로 변환하고, 그 위치에 데이터를 저장합니다.
빠른 이유는 배열 인덱스로 바로 접근하기 때문입니다. 일반 배열이나 리스트에서 특정 값을 찾으려면 처음부터 하나씩 확인해야 해서 O(n)이지만, 해시 테이블은 해시 함수로 위치를 바로 계산하니까 O(1)로 찾을 수 있습니다.

예를 들어 로그인 세션 관리에서 세션 ID "abc123"으로 사용자 정보를 찾는다면, 해시 함수가 "abc123"을 인덱스 7로 변환하고 배열 7번 위치에 바로 접근해서 사용자 정보를 꺼냅니다. 그래서 캐시, 세션 관리, Java의 HashMap 같은 곳에서 많이 사용합니다.

## **예상 꼬리질문**

**Q1. 해시 충돌(Collision)이란 무엇인가요?**

A. 서로 다른 key가 같은 인덱스로 변환되는 현상입니다. "user123"과 "admin456"이 둘 다 인덱스 7로 계산되면 같은 위치에 두 개를 저장해야 하는 문제가 생깁니다.
해결 방법은 크게 두 가지가 있습니다. 체이닝은 같은 인덱스에 연결 리스트로 여러 값을 이어붙이는 방식입니다. 개방 주소법은 충돌이 발생하면 다른 빈 공간을 찾아서 저장하는 방식입니다.
충돌이 많아지면 O(1)이 보장 안 되고 최악의 경우 O(n)까지 느려질 수 있어서, 좋은 해시 함수와 적절한 테이블 크기가 중요합니다.


**Q2. Java에서 HashMap과 HashTable의 차이는 뭔가요?**

A. 가장 큰 차이는 동기화입니다. HashTable은 메서드에 synchronized가 걸려있어서 멀티스레드 환경에서 안전하지만 느립니다. HashMap은 동기화가 없어서 빠르지만 스레드 안전하지 않습니다.
그리고 HashMap은 null key와 null value를 허용하는데, HashTable은 null을 허용하지 않습니다. 실무에서는 HashMap을 기본으로 쓰고, 동기화가 필요하면 ConcurrentHashMap을 씁니다.

---


