## 📚 질문 목록

1. [배열(Array)과 연결 리스트(LinkedList)의 차이점은 무엇인가요? 데이터를 저장하는 방식이 어떻게 다르고, 그로 인해 어떤 장단점이 생기나요?](#1-배열array과-연결-리스트linkedlist의-차이점은-무엇인가요-데이터를-저장하는-방식이-어떻게-다르고-그로-인해-어떤-장단점이-생기나요)
2. [스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?](#2-스택stack과-큐queue의-차이점은-무엇인가요)
3. [해시 테이블은 무엇이고, 왜 그렇게 빠른가요?](#3-해시-테이블은-무엇이고-왜-그렇게-빠른가요)

---

이렇게 작성하시면 됩니다! 나중에 질문이 추가되면 번호를 늘려가면서 목록을 확장하시면 돼요.

## 1. 배열(Array)과 연결 리스트(LinkedList)의 차이점은 무엇인가요? 
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.27/2026.01.07)

**답변**

배열은 연속된 메모리 공간에 데이터를 저장해서 인덱스로 바로 접근할 수 있습니다. 그래서 조회가 O(1)로 빠릅니다. 대신 중간에 삽입하거나 삭제하면 나머지 요소들을 밀거나 당겨야 해서 O(n)이 걸립니다.
연결 리스트는 노드가 포인터로 연결된 구조라서 원하는 위치까지 순차적으로 따라가야 합니다. 조회는 O(n)이지만, 삽입/삭제는 포인터만 바꾸면 되니까 O(1)입니다.
그래서 조회가 빈번하면 배열이 유리하고, 삽입/삭제가 빈번하면 연결 리스트가 유리합니다.

## **예상 꼬리질문**

**Q1. 캐시 지역성(Cache Locality)이 뭔가요?**

A. CPU가 메모리에서 데이터를 읽을 때 해당 데이터만 가져오는 게 아니라 인접한 메모리도 함께 캐시에 올립니다.
배열은 연속된 메모리에 저장되니까 하나를 읽으면 옆에 있는 것들도 같이 캐시에 올라와서 다음 접근이 빠릅니다.

근데 연결 리스트는 노드가 메모리에 흩어져 있어서 매번 새로운 위치를 읽어야 하고, 캐시 미스가 자주 발생합니다. 그래서 같은 순차 탐색이라도 배열이 훨씬 빠를 수 있습니다.

**Q2. 배열과 연결 리스트는 각각 언제 사용하나요?**

A. 배열은 인덱스로 자주 접근하거나 데이터 크기가 어느 정도 예측 가능할 때 씁니다. 이미지 처리나 행렬 연산처럼 연속적으로 데이터를 읽는 작업에 유리합니다.
연결 리스트는 삽입/삭제가 빈번할 때 씁니다. 브라우저 히스토리나 음악 플레이리스트처럼 중간에 추가/제거가 자주 일어나는 경우에 적합합니다.

실무에서는 ArrayList처럼 배열 기반이면서 크기가 동적으로 늘어나는 자료구조를 많이 씁니다.

**Q3. Java에서 ArrayList와 LinkedList 중 뭘 써야 하나요?**
A. 대부분의 경우 ArrayList가 낫습니다. 조회가 빠르고 캐시 지역성도 좋아서 전반적인 성능이 좋습니다. 
LinkedList는 맨 앞에 삽입/삭제가 빈번할 때만 고려하는데, 사실 그런 경우에도 ArrayDeque가 더 빠른 경우가 많습니다. 
그래서 실무에서는 특별한 이유가 없으면 ArrayList를 기본으로 씁니다.

---

## 2. 스택(Stack)과 큐(Queue)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.30)

**답변**

스택과 큐는 데이터를 저장하고 꺼내는 순서가 다른 선형 자료구조입니다.
스택은 LIFO 구조로, 마지막에 들어간 데이터가 먼저 나옵니다. 마치 접시를 쌓을 때 위에서부터 하나씩 빼내는 것과 같습니다. 데이터를 넣을 때는 push, 꺼낼 때는 pop 연산을 사용합니다.
큐는 FIFO 구조로, 먼저 들어간 데이터가 먼저 나옵니다. 마치 줄을 서서 기다리는 것처럼, 먼저 온 사람이 먼저 나가는 방식입니다. 데이터를 넣을 때는 enqueue, 꺼낼 때는 dequeue 연산을 사용합니다.
두 자료구조 모두 삽입과 삭제 연산이 O(1)의 시간복잡도를 가집니다.

사용 예시
스택: 함수 호출 스택(Call Stack), 브라우저 뒤로가기 기능, 실행 취소(Undo) 기능
큐: 프린터 출력 대기열, 작업 스케줄링, BFS(너비 우선 탐색) 알고리즘

## **예상 꼬리질문**

**Q1. 스택 오버플로우(Stack Overflow)란 무엇인가요?**

A. 스택 오버플로우는 스택 메모리 공간이 가득 차서 더 이상 데이터를 push할 수 없는 상태를 말합니다. 
주로 재귀 함수가 종료 조건 없이 무한히 호출되거나, 너무 깊은 재귀 호출이 발생할 때 일어납니다. 
예를 들어 factorial 함수에서 base case를 빠뜨리면 함수가 계속 호출되면서 스택 오버플로우가 발생할 수 있습니다.

---

## 3. 해시 테이블은 무엇이고, 왜 그렇게 빠른가요?

**답변**

해시 테이블은 **키(key)와 값(value)을 쌍으로 저장**하는 자료구조로, 해시 함수를 사용해 키를 배열의 인덱스로 변환하여 데이터를 저장하고 조회합니다.

해시 테이블이 빠른 이유는 **직접 접근(Direct Access)** 방식을 사용하기 때문입니다. 

일반적인 배열이나 리스트에서 특정 값을 찾으려면 처음부터 끝까지 하나씩 확인해야 하지만(O(n)), 해시 테이블은 해시 함수를 통해 저장 위치를 바로 계산할 수 있어 평균 O(1)의 시간 복잡도로 데이터를 찾을 수 있습니다.

예를 들어, 사용자 ID "user123"으로 회원 정보를 찾는다면:
1. 해시 함수가 "user123"을 숫자 인덱스(예: 7)로 변환
2. 배열의 7번 위치에 바로 접근하여 데이터 조회
3. 중간 과정 없이 한 번에 원하는 데이터에 도달

이러한 특성 덕분에 데이터베이스의 인덱스, 캐시 시스템, 프로그래밍 언어의 딕셔너리/맵 자료구조 등에 널리 활용됩니다.

## **예상 꼬리질문**

**Q1. 해시 충돌(Collision)이란 무엇인가요?**

A. 해시 충돌은 서로 다른 키가 해시 함수를 통해 같은 인덱스로 매핑되는 현상입니다.

예를 들어 "user123"과 "admin456"이라는 서로 다른 키가 모두 인덱스 7로 계산되면, 같은 위치에 두 개의 데이터를 저장해야 하는 문제가 발생합니다.

**해결 방법**

1. **체이닝(Chaining)**: 같은 인덱스에 연결 리스트로 여러 값을 저장합니다. 충돌이 발생하면 해당 위치에 리스트 형태로 데이터를 이어붙이고, 조회 시 리스트를 순회하며 올바른 키를 찾습니다.

2. **개방 주소법(Open Addressing)**: 충돌이 발생하면 다른 빈 공간을 찾아 저장합니다. 선형 탐사, 제곱 탐사, 이중 해싱 등의 방법이 있습니다.

해시 충돌이 많이 발생하면 O(1)의 성능이 보장되지 않고 최악의 경우 O(n)까지 느려질 수 있기 때문에, 좋은 해시 함수 설계와 적절한 테이블 크기 유지가 중요합니다.

---


