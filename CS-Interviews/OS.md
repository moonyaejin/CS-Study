## 📋 질문 목록
1. [뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점](#1-뮤텍스mutex와-세마포어semaphore의-차이점은-무엇인가요)
2. [페이징(Paging)과 세그멘테이션(Segmentation)의 차이점](#2-페이징paging과-세그멘테이션segmentation의-차이점은-무엇인가요)
3. [Blocking I/O와 Non-Blocking I/O의 차이점](#3-blocking-io와-non-blocking-io의-차이점은-무엇인가요)

---

## 1. 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.24)

**답변**

뮤텍스와 세마포어는 둘 다 **멀티스레드 환경에서 동시성 제어를 위한 동기화 기법**이지만, 동작 방식과 사용 목적에서 결정적인 차이가 있습니다.

**뮤텍스 (Mutex)**

뮤텍스는 Mutual Exclusion(상호 배제)의 약자로, **공유 자원에 대한 배타적 접근**을 보장하는 잠금 메커니즘입니다.
- **단일 접근**: 오직 한 개의 스레드만 임계 영역에 진입 가능합니다. 화장실 열쇠를 떠올리면 쉽습니다 - 한 사람이 열쇠를 가지고 들어가면 다른 사람은 기다려야 합니다.
- **소유권 보장**: 잠금을 획득한 스레드만이 해제할 수 있습니다. Thread A가 lock()을 호출했다면 반드시 Thread A가 unlock()을 호출해야 합니다.
- **재진입 가능**: 많은 구현에서 같은 스레드가 여러 번 lock을 획득할 수 있는 재귀적 뮤텍스(Recursive Mutex)를 지원합니다.

**세마포어 (Semaphore)**

세마포어는 **정해진 개수의 자원을 관리**하는 신호 메커니즘으로, 카운터를 사용해 동시 접근을 제어합니다.

- **다중 접근 가능**: 카운터 값(N)만큼의 스레드가 동시에 접근 가능합니다. 주차장의 빈 자리 개수를 생각하면 됩니다 - 10대 주차 가능하면 10대까지 들어올 수 있습니다.
- **소유권 없음**: wait()을 호출한 스레드와 signal()을 호출하는 스레드가 달라도 됩니다. 이는 스레드 간 시그널링에 유용합니다.
- **두 가지 종류**:
  - Binary Semaphore: 0과 1만 가지는 세마포어 (뮤텍스와 유사하지만 소유권이 없음)
  - Counting Semaphore: 0부터 N까지 값을 가지는 세마포어

**핵심 차이점 정리**

| 구분 | 뮤텍스 | 세마포어 |
|------|--------|----------|
| **동시 접근** | 1개 스레드만 | N개 스레드 가능 |
| **소유권** | 있음 (lock한 스레드가 unlock) | 없음 (누구나 signal 가능) |
| **카운터** | 없음 (잠김/풀림 상태만) | 있음 (0~N 값 가짐) |
| **주 용도** | 임계 영역 보호 | 자원 카운팅, 스레드 동기화 |
| **속도** | 상대적으로 빠름 | 상대적으로 느림 |

## **예상 꼬리질문**

**Q1. Binary Semaphore와 Mutex는 기능상 거의 비슷해 보이는데, 왜 따로 존재하나요?**

A. 핵심은 **소유권(Ownership)**과 **용도**의 차이입니다.

뮤텍스는 **"내가 잠근 것은 내가 푼다"** 원칙이 있어서 우선순위 상속 같은 고급 기능을 구현할 수 있습니다. 예를 들어 낮은 우선순위 스레드가 뮤텍스를 잡고 있을 때, 높은 우선순위 스레드가 대기하면 일시적으로 우선순위를 올려주는 기능이 가능합니다. 이는 우선순위 역전 문제를 해결합니다.

Binary Semaphore는 소유권이 없어서 **스레드 간 시그널링**에 적합합니다. 생산자-소비자 패턴에서 생산자가 signal()로 "데이터 준비됐어"라고 알리고, 소비자가 wait()으로 기다리는 구조를 만들 수 있습니다. 뮤텍스로는 이런 패턴을 구현하기 어렵습니다.
**세마포어 사용 (적합)**
```java
class ProducerConsumer {
    private Semaphore items = new Semaphore(0);  // 처음엔 아이템 없음
    private Queue<String> queue = new LinkedList<>();
    
    // 생산자
    public void produce() {
        queue.offer("새 아이템");
        items.release();  // "아이템 준비됐어" 신호
    }
    
    // 소비자
    public void consume() throws InterruptedException {
        items.acquire();  // 아이템 있을 때까지 대기
        String item = queue.poll();
        System.out.println("소비: " + item);
    }
}
```

**뮤텍스 사용 (부적합)**
```java
class ProducerConsumerWrong {
    private Object mutex = new Object();
    private Queue<String> queue = new LinkedList<>();
    
    // 생산자
    public void produce() {
        synchronized(mutex) {
            queue.offer("새 아이템");
        }
        // 소비자에게 어떻게 알려주지? 계속 확인해야 함
    }
    
    // 소비자
    public void consume() {
        synchronized(mutex) {
            // 아이템이 있는지 계속 확인해야 함 (비효율적)
            while(queue.isEmpty()) {
                // Busy waiting... 
            }
            queue.poll();
        }
    }
}
```

즉, 뮤텍스는 "보호"가 목적이고, 세마포어는 "정해진 개수만큼 허용하며, 신호와 카운팅"이 목적입니다.

---

## 2. 페이징(Paging)과 세그멘테이션(Segmentation)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.25)

**답변**

페이징과 세그멘테이션은 모두 **가상 메모리를 물리 메모리에 매핑하는 메모리 관리 기법**입니다.

**페이징**은 메모리를 **고정된 크기의 페이지**로 나누어 관리합니다. 프로세스의 가상 메모리를 페이지 단위로 쪼개고, 물리 메모리도 같은 크기의 프레임으로 나눠서 매핑하는 방식이죠. 
예를 들어 4KB 단위로 메모리를 나누면, 프로그램이 100KB를 사용하든 1MB를 사용하든 항상 4KB 단위로 쪼개져서 저장됩니다.

**세그멘테이션**은 메모리를 **논리적인 의미 단위의 세그먼트**로 나누어 관리합니다. 코드 영역, 데이터 영역, 스택 영역처럼 프로그램의 논리적 구조에 맞춰 크기가 가변적인 세그먼트로 나누는 방식입니다.

**주요 차이점**
- 페이징: 고정 크기 분할 → 내부 단편화 발생 가능, 관리가 단순함
- 세그멘테이션: 가변 크기 분할 → 외부 단편화 발생 가능, 논리적 구조 반영


## **예상 꼬리질문**

**Q1. 내부 단편화와 외부 단편화는 무엇인가요?**

A. 내부 단편화는 할당된 메모리 공간 내부에서 사용되지 않는 공간이 생기는 현상입니다. 페이징에서 발생하는데, 예를 들어 페이지 크기가 4KB인데 프로세스가 3KB만 필요하면 1KB가 낭비됩니다.

외부 단편화는 전체 메모리 공간은 충분한데, 연속된 공간이 없어서 할당할 수 없는 현상입니다. 세그멘테이션에서 발생하는데, 예를 들어 100KB 세그먼트를 할당하려는데 메모리에 50KB, 30KB, 40KB 조각들만 흩어져 있으면 총 120KB가 남았어도 할당할 수 없습니다.

---

Blocking I/O와 Non-Blocking I/O는 **운영체제(OS)** 카테고리가 더 적합해요! I/O 처리 방식은 OS의 시스템 콜 레벨에서 정의되는 개념이거든요. 네트워크 프로그래밍에서 자주 언급되긴 하지만, 본질적으로는 OS가 I/O를 어떻게 처리하느냐에 관한 내용이에요.

먼저 GitHub 레포지토리 구조를 확인해볼게요!GitHub 페이지가 완전히 로드되지 않았네요. 하지만 양식에 맞춰 정리해드릴게요!

---

## 3. Blocking I/O와 Non-Blocking I/O의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.03)

**답변**

Blocking I/O와 Non-Blocking I/O는 **I/O 작업 요청 후 프로세스가 어떻게 동작하느냐**의 차이입니다.

**Blocking I/O**는 I/O 작업이 완료될 때까지 호출한 스레드가 **대기 상태로 멈춰있는** 방식입니다. 예를 들어 파일을 읽는 `read()` 호출 시, 데이터가 준비될 때까지 해당 스레드는 다른 작업을 수행하지 못하고 기다립니다.

**Non-Blocking I/O**는 I/O 작업 요청 후 완료 여부와 관계없이 **즉시 제어권이 반환**되는 방식입니다. 데이터가 아직 준비되지 않았다면 에러 코드(EAGAIN, EWOULDBLOCK)를 반환하고, 스레드는 다른 작업을 계속 수행할 수 있습니다.

| 구분 | Blocking I/O | Non-Blocking I/O |
|------|-------------|------------------|
| 제어권 | I/O 완료까지 반환 안 됨 | 즉시 반환 |
| 스레드 상태 | 대기(블록) | 계속 실행 가능 |
| 구현 복잡도 | 단순 | 상대적으로 복잡 |
| 자원 효율성 | 낮음 (대기 시간 낭비) | 높음 (대기 시간 활용 가능) |


## **예상 꼬리질문**

**Q1. Blocking I/O가 단순한데도 Non-Blocking I/O를 사용하는 이유는 무엇인가요?**

A. Blocking I/O는 구현이 단순하지만, 동시에 많은 요청을 처리해야 하는 상황에서 비효율적입니다. 예를 들어 웹 서버에서 1000개의 동시 연결을 처리할 때, Blocking 방식이라면 각 연결마다 스레드가 필요하고 대부분의 스레드가 I/O 대기 상태로 자원을 낭비하게 됩니다.

Non-Blocking I/O를 사용하면 하나의 스레드가 여러 I/O 작업을 관리할 수 있어, 적은 스레드로도 수천 개의 동시 연결을 효율적으로 처리할 수 있습니다. Node.js가 단일 스레드로 높은 동시성을 달성하는 것이 대표적인 예입니다.


**Q2. Non-Blocking I/O와 비동기(Asynchronous) I/O는 같은 개념인가요?**

A. 아니요, 다른 개념입니다. 둘 다 스레드가 멈추지 않는다는 점은 비슷하지만 동작 방식이 다릅니다.

**Non-Blocking I/O**는 호출 즉시 반환되지만, 작업 완료 여부를 **직접 확인(polling)**해야 합니다. "데이터 준비됐어?" 하고 계속 물어봐야 하는 거죠.

**Asynchronous I/O**는 작업 완료 시 **시스템이 알려주는(callback/event)** 방식입니다. "다 되면 알려줘"라고 해두고 다른 일을 하다가 완료 알림을 받습니다.

즉, Non-Blocking은 "기다리지 않음"에 초점이 있고, Asynchronous는 "완료 통지 방식"에 초점이 있습니다.


**Q3. I/O 멀티플렉싱(select, poll, epoll)은 무엇이고, Non-Blocking I/O와 어떤 관계가 있나요?**

A. I/O 멀티플렉싱은 **하나의 스레드가 여러 I/O를 동시에 감시**할 수 있게 해주는 기법입니다.

Non-Blocking I/O만 사용하면 각 소켓마다 "데이터 있어?"를 반복적으로 확인해야 하는데, 이는 CPU 낭비입니다. I/O 멀티플렉싱을 사용하면 "이 1000개 소켓 중 준비된 게 있으면 알려줘"라고 한 번에 요청하고, 준비된 소켓만 처리할 수 있습니다.

- **select**: 가장 오래된 방식, 감시 가능한 fd 수 제한(보통 1024개)
- **poll**: select의 fd 제한 해결, 하지만 여전히 전체 fd를 순회
- **epoll**(Linux): 이벤트 기반으로 준비된 fd만 반환, 대규모 연결에 효율적

Node.js, Nginx 같은 고성능 서버들이 Non-Blocking I/O + epoll 조합을 사용합니다.
