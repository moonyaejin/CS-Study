## 📋 질문 목록
1. [뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점](#1-뮤텍스mutex와-세마포어semaphore의-차이점은-무엇인가요)
2. [페이징(Paging)과 세그멘테이션(Segmentation)의 차이점](#2-페이징paging과-세그멘테이션segmentation의-차이점은-무엇인가요)
3. [Blocking I/O와 Non-Blocking I/O의 차이점](#3-blocking-io와-non-blocking-io의-차이점은-무엇인가요)
4. [프로세스(Process)와 스레드(Thread)의 차이점은 무엇인가요?](#4-프로세스process와-스레드thread의-차이점은-무엇인가요)
5. [교착 상태(Deadlock)란 무엇인가요?](#5-교착-상태deadlock란-무엇인가요)


## 1. 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.24)

**답변**

뮤텍스와 세마포어는 둘 다 **멀티스레드 환경에서 동시성 제어를 위한 동기화 기법**이지만, 동작 방식과 사용 목적에서 결정적인 차이가 있습니다.

**뮤텍스 (Mutex)**

뮤텍스는 Mutual Exclusion(상호 배제)의 약자로, **공유 자원에 대한 배타적 접근**을 보장하는 잠금 메커니즘입니다.
- **단일 접근**: 오직 한 개의 스레드만 임계 영역에 진입 가능합니다. 화장실 열쇠를 떠올리면 쉽습니다 - 한 사람이 열쇠를 가지고 들어가면 다른 사람은 기다려야 합니다.
- **소유권 보장**: 잠금을 획득한 스레드만이 해제할 수 있습니다. Thread A가 lock()을 호출했다면 반드시 Thread A가 unlock()을 호출해야 합니다.
- **재진입 가능**: 많은 구현에서 같은 스레드가 여러 번 lock을 획득할 수 있는 재귀적 뮤텍스(Recursive Mutex)를 지원합니다.

**세마포어 (Semaphore)**

세마포어는 **정해진 개수의 자원을 관리**하는 신호 메커니즘으로, 카운터를 사용해 동시 접근을 제어합니다.

- **다중 접근 가능**: 카운터 값(N)만큼의 스레드가 동시에 접근 가능합니다. 주차장의 빈 자리 개수를 생각하면 됩니다 - 10대 주차 가능하면 10대까지 들어올 수 있습니다.
- **소유권 없음**: wait()을 호출한 스레드와 signal()을 호출하는 스레드가 달라도 됩니다. 이는 스레드 간 시그널링에 유용합니다.
- **두 가지 종류**:
  - Binary Semaphore: 0과 1만 가지는 세마포어 (뮤텍스와 유사하지만 소유권이 없음)
  - Counting Semaphore: 0부터 N까지 값을 가지는 세마포어

**핵심 차이점 정리**

| 구분 | 뮤텍스 | 세마포어 |
|------|--------|----------|
| **동시 접근** | 1개 스레드만 | N개 스레드 가능 |
| **소유권** | 있음 (lock한 스레드가 unlock) | 없음 (누구나 signal 가능) |
| **카운터** | 없음 (잠김/풀림 상태만) | 있음 (0~N 값 가짐) |
| **주 용도** | 임계 영역 보호 | 자원 카운팅, 스레드 동기화 |
| **속도** | 상대적으로 빠름 | 상대적으로 느림 |

## **예상 꼬리질문**

**Q1. Binary Semaphore와 Mutex는 기능상 거의 비슷해 보이는데, 왜 따로 존재하나요?**

A. 핵심은 **소유권(Ownership)**과 **용도**의 차이입니다.

뮤텍스는 **"내가 잠근 것은 내가 푼다"** 원칙이 있어서 우선순위 상속 같은 고급 기능을 구현할 수 있습니다. 예를 들어 낮은 우선순위 스레드가 뮤텍스를 잡고 있을 때, 높은 우선순위 스레드가 대기하면 일시적으로 우선순위를 올려주는 기능이 가능합니다. 이는 우선순위 역전 문제를 해결합니다.

Binary Semaphore는 소유권이 없어서 **스레드 간 시그널링**에 적합합니다. 생산자-소비자 패턴에서 생산자가 signal()로 "데이터 준비됐어"라고 알리고, 소비자가 wait()으로 기다리는 구조를 만들 수 있습니다. 뮤텍스로는 이런 패턴을 구현하기 어렵습니다.
**세마포어 사용 (적합)**
```java
class ProducerConsumer {
    private Semaphore items = new Semaphore(0);  // 처음엔 아이템 없음
    private Queue<String> queue = new LinkedList<>();
    
    // 생산자
    public void produce() {
        queue.offer("새 아이템");
        items.release();  // "아이템 준비됐어" 신호
    }
    
    // 소비자
    public void consume() throws InterruptedException {
        items.acquire();  // 아이템 있을 때까지 대기
        String item = queue.poll();
        System.out.println("소비: " + item);
    }
}
```

**뮤텍스 사용 (부적합)**
```java
class ProducerConsumerWrong {
    private Object mutex = new Object();
    private Queue<String> queue = new LinkedList<>();
    
    // 생산자
    public void produce() {
        synchronized(mutex) {
            queue.offer("새 아이템");
        }
        // 소비자에게 어떻게 알려주지? 계속 확인해야 함
    }
    
    // 소비자
    public void consume() {
        synchronized(mutex) {
            // 아이템이 있는지 계속 확인해야 함 (비효율적)
            while(queue.isEmpty()) {
                // Busy waiting... 
            }
            queue.poll();
        }
    }
}
```

즉, 뮤텍스는 "보호"가 목적이고, 세마포어는 "정해진 개수만큼 허용하며, 신호와 카운팅"이 목적입니다.

---

## 2. 페이징(Paging)과 세그멘테이션(Segmentation)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.25)

**답변**

페이징과 세그멘테이션은 모두 **가상 메모리를 물리 메모리에 매핑하는 메모리 관리 기법**입니다.

**페이징**은 메모리를 **고정된 크기의 페이지**로 나누어 관리합니다. 프로세스의 가상 메모리를 페이지 단위로 쪼개고, 물리 메모리도 같은 크기의 프레임으로 나눠서 매핑하는 방식이죠. 
예를 들어 4KB 단위로 메모리를 나누면, 프로그램이 100KB를 사용하든 1MB를 사용하든 항상 4KB 단위로 쪼개져서 저장됩니다.

**세그멘테이션**은 메모리를 **논리적인 의미 단위의 세그먼트**로 나누어 관리합니다. 코드 영역, 데이터 영역, 스택 영역처럼 프로그램의 논리적 구조에 맞춰 크기가 가변적인 세그먼트로 나누는 방식입니다.

**주요 차이점**
- 페이징: 고정 크기 분할 → 내부 단편화 발생 가능, 관리가 단순함
- 세그멘테이션: 가변 크기 분할 → 외부 단편화 발생 가능, 논리적 구조 반영


## **예상 꼬리질문**

**Q1. 내부 단편화와 외부 단편화는 무엇인가요?**

A. 내부 단편화는 할당된 메모리 공간 내부에서 사용되지 않는 공간이 생기는 현상입니다. 페이징에서 발생하는데, 예를 들어 페이지 크기가 4KB인데 프로세스가 3KB만 필요하면 1KB가 낭비됩니다.

외부 단편화는 전체 메모리 공간은 충분한데, 연속된 공간이 없어서 할당할 수 없는 현상입니다. 세그멘테이션에서 발생하는데, 예를 들어 100KB 세그먼트를 할당하려는데 메모리에 50KB, 30KB, 40KB 조각들만 흩어져 있으면 총 120KB가 남았어도 할당할 수 없습니다.

---

Blocking I/O와 Non-Blocking I/O는 **운영체제(OS)** 카테고리가 더 적합해요! I/O 처리 방식은 OS의 시스템 콜 레벨에서 정의되는 개념이거든요. 네트워크 프로그래밍에서 자주 언급되긴 하지만, 본질적으로는 OS가 I/O를 어떻게 처리하느냐에 관한 내용이에요.

먼저 GitHub 레포지토리 구조를 확인해볼게요!GitHub 페이지가 완전히 로드되지 않았네요. 하지만 양식에 맞춰 정리해드릴게요!

---

## 3. Blocking I/O와 Non-Blocking I/O의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.03)

**답변**

Blocking I/O와 Non-Blocking I/O는 **I/O 작업 요청 후 프로세스가 어떻게 동작하느냐**의 차이입니다.

**Blocking I/O**는 I/O 작업이 완료될 때까지 호출한 스레드가 **대기 상태로 멈춰있는** 방식입니다. 예를 들어 파일을 읽는 `read()` 호출 시, 데이터가 준비될 때까지 해당 스레드는 다른 작업을 수행하지 못하고 기다립니다.

**Non-Blocking I/O**는 I/O 작업 요청 후 완료 여부와 관계없이 **즉시 제어권이 반환**되는 방식입니다. 데이터가 아직 준비되지 않았다면 에러 코드(EAGAIN, EWOULDBLOCK)를 반환하고, 스레드는 다른 작업을 계속 수행할 수 있습니다.

| 구분 | Blocking I/O | Non-Blocking I/O |
|------|-------------|------------------|
| 제어권 | I/O 완료까지 반환 안 됨 | 즉시 반환 |
| 스레드 상태 | 대기(블록) | 계속 실행 가능 |
| 구현 복잡도 | 단순 | 상대적으로 복잡 |
| 자원 효율성 | 낮음 (대기 시간 낭비) | 높음 (대기 시간 활용 가능) |


## **예상 꼬리질문**

**Q1. Blocking I/O가 단순한데도 Non-Blocking I/O를 사용하는 이유는 무엇인가요?**

A. Blocking I/O는 구현이 단순하지만, 동시에 많은 요청을 처리해야 하는 상황에서 비효율적입니다. 예를 들어 웹 서버에서 1000개의 동시 연결을 처리할 때, Blocking 방식이라면 각 연결마다 스레드가 필요하고 대부분의 스레드가 I/O 대기 상태로 자원을 낭비하게 됩니다.

Non-Blocking I/O를 사용하면 하나의 스레드가 여러 I/O 작업을 관리할 수 있어, 적은 스레드로도 수천 개의 동시 연결을 효율적으로 처리할 수 있습니다. Node.js가 단일 스레드로 높은 동시성을 달성하는 것이 대표적인 예입니다.


**Q2. Non-Blocking I/O와 비동기(Asynchronous) I/O는 같은 개념인가요?**

A. 아니요, 다른 개념입니다. 둘 다 스레드가 멈추지 않는다는 점은 비슷하지만 동작 방식이 다릅니다.

**Non-Blocking I/O**는 호출 즉시 반환되지만, 작업 완료 여부를 **직접 확인(polling)**해야 합니다. "데이터 준비됐어?" 하고 계속 물어봐야 하는 거죠.

**Asynchronous I/O**는 작업 완료 시 **시스템이 알려주는(callback/event)** 방식입니다. "다 되면 알려줘"라고 해두고 다른 일을 하다가 완료 알림을 받습니다.

즉, Non-Blocking은 "기다리지 않음"에 초점이 있고, Asynchronous는 "완료 통지 방식"에 초점이 있습니다.


**Q3. I/O 멀티플렉싱(select, poll, epoll)은 무엇이고, Non-Blocking I/O와 어떤 관계가 있나요?**

A. I/O 멀티플렉싱은 **하나의 스레드가 여러 I/O를 동시에 감시**할 수 있게 해주는 기법입니다.

Non-Blocking I/O만 사용하면 각 소켓마다 "데이터 있어?"를 반복적으로 확인해야 하는데, 이는 CPU 낭비입니다. I/O 멀티플렉싱을 사용하면 "이 1000개 소켓 중 준비된 게 있으면 알려줘"라고 한 번에 요청하고, 준비된 소켓만 처리할 수 있습니다.

- **select**: 가장 오래된 방식, 감시 가능한 fd 수 제한(보통 1024개)
- **poll**: select의 fd 제한 해결, 하지만 여전히 전체 fd를 순회
- **epoll**(Linux): 이벤트 기반으로 준비된 fd만 반환, 대규모 연결에 효율적

Node.js, Nginx 같은 고성능 서버들이 Non-Blocking I/O + epoll 조합을 사용합니다.

---

## 4. 프로세스(Process)와 스레드(Thread)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.15)

**답변**

프로세스는 운영체제로부터 메모리를 할당받아 실행되는 **독립적인 프로그램 단위**입니다. 프로세스마다 각자의 메모리 공간을 가지고 있어서, 서로 직접 메모리를 공유할 수 없습니다.

스레드는 프로세스 안에서 실행되는 **작업의 흐름**입니다. 같은 프로세스 내의 스레드들은 메모리를 공유하기 때문에 데이터를 주고받기 쉽지만, 그만큼 동기화 문제에 주의해야 합니다.

쉽게 비유하면 프로세스는 각자 독립된 집이고, 스레드는 한 집 안에서 방을 나눠 쓰는 가족 구성원이라고 볼 수 있습니다. 집이 다르면 물건을 주고받으려면 택배를 보내야 하지만, 같은 집이면 거실에서 바로 공유할 수 있는 것처럼요.


## **예상 꼬리질문**

**Q1. 컨텍스트 스위칭(Context Switching)이란 무엇이고, 왜 프로세스가 더 비용이 큰가요?**

A. 컨텍스트 스위칭은 CPU가 현재 작업을 멈추고 다른 작업으로 전환할 때, 현재 상태를 저장하고 새 작업의 상태를 불러오는 과정입니다.

프로세스 간 전환은 메모리 공간 자체가 다르기 때문에 페이지 테이블 교체, 캐시 무효화 같은 무거운 작업이 필요합니다. 반면 스레드 간 전환은 같은 메모리 공간 안에서 실행 위치만 바꾸면 되니까 훨씬 가볍습니다.


**Q2. 멀티프로세스와 멀티스레드는 각각 언제 사용하나요?**

A. 멀티프로세스는 **안정성이 중요할 때** 사용합니다. 한 프로세스가 죽어도 다른 프로세스에 영향이 없거든요. 크롬 브라우저가 대표적인데, 탭마다 별도 프로세스라서 한 탭이 죽어도 다른 탭은 정상 동작합니다.

멀티스레드는 **자원 공유가 많고 성능이 중요할 때** 사용합니다. 메모리를 공유하니까 통신 비용이 낮고 컨텍스트 스위칭도 가볍습니다. 웹 서버에서 요청마다 스레드를 할당해서 처리하는 게 대표적인 예입니다.


**Q3. 스레드가 Stack만 별도로 가지는 이유는 무엇인가요?**

A. Stack은 함수 호출 정보와 지역 변수를 저장하는 공간입니다. 각 스레드는 독립적인 실행 흐름을 가지니까, 각자 어떤 함수를 호출했고 어디까지 실행했는지를 따로 관리해야 합니다.

만약 Stack을 공유하면 A 스레드가 함수 호출하는 중에 B 스레드가 다른 함수를 호출하면서 호출 스택이 엉켜버립니다. 그래서 스레드마다 독립적인 Stack이 필요하고, 나머지 Heap이나 Data 영역은 공유해서 데이터를 주고받는 겁니다.


**Q4. 스레드를 공유하면 어떤 문제가 생기나요?**

A. 메모리를 공유하다 보니 **동시성 문제**가 발생합니다. 두 스레드가 동시에 같은 변수를 수정하면 예상치 못한 결과가 나올 수 있습니다.

예를 들어 잔액이 1000원인데 두 스레드가 동시에 500원을 차감하면, 둘 다 1000원을 읽고 500원을 빼서 각각 500원을 저장할 수 있습니다. 결과적으로 한 번만 차감된 것처럼 되는 거죠. 이런 문제를 방지하려고 뮤텍스나 세마포어 같은 동기화 기법을 사용합니다.

---

**피드백**

잘 정리했어요! 한 부분만 살짝 수정할게요.

"스레드 하나 당 자원을 하나만 쓸 수 있고" → **"자원 하나를 동시에 여러 스레드가 쓸 수 없고"**가 더 정확해요.

상호 배제는 "스레드가 자원을 하나만 쓴다"가 아니라, "자원이 한 번에 하나의 스레드만 사용할 수 있다"는 뜻이에요. 스레드는 여러 자원을 가질 수 있거든요!

나머지는 다 좋아요 👍 질문 목록이랑 함께 정리해드릴게요.

---

## 5. 교착 상태(Deadlock)란 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.30)

**답변**

교착 상태는 프로세스나 스레드가 서로의 자원을 기다리면서, 자원을 놓아주지 않아 영원히 진행되지 않는 상태입니다.

교착 상태는 네 가지 조건이 모두 만족될 때 발생합니다. 상호 배제, 점유와 대기, 비선점, 순환 대기입니다. 예를 들어 상호 배제는 프린터처럼 한 번에 하나의 프로세스만 사용할 수 있는 자원에서 성립합니다.

교착 상태를 해결하려면 이 네 가지 조건 중 하나를 깨면 됩니다. 자원에 순서를 정해서 순환 대기를 깨거나, 필요한 자원을 한 번에 요청하게 해서 점유 대기를 깨거나, 자원을 강제로 회수할 수 있게 해서 비선점을 깰 수 있습니다. 다만 상호 배제를 깨는 건 자원 특성상 어려운 경우가 많습니다.


## **예상 꼬리질문**

**Q1. 교착 상태 발생 조건 4가지를 각각 설명해주세요.**

A. 첫 번째는 **상호 배제**로, 자원을 한 번에 하나의 스레드만 사용할 수 있는 것입니다. 두 번째는 **점유 대기**로, 자원을 가진 채로 다른 자원을 기다리는 것입니다. 세 번째는 **비선점**으로, 자원을 강제로 뺏을 수 없고 자발적으로만 놓을 수 있는 것입니다. 네 번째는 **순환 대기**로, A는 B가 가진 자원을, B는 A가 가진 자원을 기다리는 원형 구조입니다.

**Q2. 교착 상태를 예방하는 방법과 회피하는 방법의 차이는 무엇인가요?**

A. **예방**은 아예 네 가지 조건 중 하나가 성립하지 않도록 시스템을 설계하는 것입니다. 예를 들어 자원 요청 순서를 정해서 순환 대기를 원천 차단하는 식이죠. 안전하지만 자원 활용도가 떨어질 수 있습니다.

**회피**는 조건이 성립할 수 있지만, 자원을 할당하기 전에 "이거 주면 교착 상태 생기겠다" 싶으면 안 주는 방식입니다. 은행원 알고리즘이 대표적인데, 자원을 줬을 때 안전한 상태인지 미리 계산해서 판단합니다.

**Q3. 실무에서 교착 상태를 어떻게 처리할까요?**

A. 사실 실무에서는 교착 상태 예방이나 회피를 엄격하게 적용하기보다, **탐지 후 복구** 방식을 많이 씁니다. 교착 상태가 자주 발생하지 않으니까, 발생하면 그때 탐지해서 프로세스를 강제 종료하거나 롤백합니다.

데이터베이스에서는 트랜잭션 간 교착 상태가 발생하면 하나를 강제로 롤백시키고, 개발자에게 알려주는 식으로 처리합니다.

---
