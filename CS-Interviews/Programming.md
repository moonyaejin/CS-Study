## 📚 질문 목록
1. [컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점은 무엇인가요?](#1-컴파일러compiler와-인터프리터interpreter의-차이점은-무엇인가요-어떤-언어가-컴파일러를-쓰고-어떤-언어가-인터프리터를-쓰는지-예시를-들어봐도-좋습니다)
2. [Git에서 Merge와 Rebase는 어떤 차이가 있나요?](#2-git에서-merge와-rebase는-어떤-차이가-있나요)
3. [CI/CD란 무엇이고, 왜 필요한가요?](#3-cicd란-무엇이고-왜-필요한가요)
4. [가비지 컬렉션(Garbage Collection)이란 무엇이고, 어떻게 동작하나요?](#4-가비지-컬렉션garbage-collection이란-무엇이고-어떻게-동작하나요)
5. [이벤트 루프(Event Loop)란 무엇이고, 어떻게 동작하나요?](#5-이벤트-루프event-loop란-무엇이고-어떻게-동작하나요)

---

## 1. 컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점은 무엇인가요? 어떤 언어가 컴파일러를 쓰고, 어떤 언어가 인터프리터를 쓰는지 예시를 들어봐도 좋습니다.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.29/2026.01.12)

**답변**

둘 다 사람이 작성한 코드를 컴퓨터가 이해할 수 있는 기계어로 변환해주는데, 변환하는 방식이 다릅니다.

컴파일러는 전체 코드를 한 번에 기계어로 변환해서 실행 파일을 만듭니다. 번역은 오래 걸리지만, 한 번 만들어두면 실행할 때는 빠릅니다. C나 Java가 대표적입니다.
컴파일러는 실행 속도가 빠르고 최적화가 가능한데, 컴파일 시간이 오래 걸리고 플랫폼마다 다시 컴파일해야 합니다.

인터프리터는 코드를 한 줄씩 읽으면서 바로 실행합니다. 별도의 실행 파일을 만들지 않아서 바로 실행해볼 수 있지만, 매번 해석하니까 실행 속도는 느립니다. 
Python이나 JavaScript가 대표적입니다.
인터프리터는 바로 실행해볼 수 있어서 개발이 편하고 디버깅도 쉬운데, 실행 속도가 느리고 소스 코드가 노출됩니다.

그래서 성능이 중요한 시스템 프로그래밍에는 C 같은 컴파일 언어를, 빠른 개발이 필요한 스크립트나 프로토타입에는 파이썬 같은 인터프리터 언어를 많이 사용합니다.
**언어별 예시**

- **컴파일 언어**: C, C++, Java(중간), Rust, Swift
- **인터프리터 언어**: Python, JavaScript, PHP

## **예상 꼬리질문**

**Q1. 컴파일러 언어가 더 빠른데, 왜 인터프리터 언어를 사용하나요?**

A. 개발 생산성과 편의성 때문입니다. 인터프리터 언어는 코드를 수정한 후 바로 실행해볼 수 있어서 개발 속도가 빠르고, 디버깅이 쉽습니다. 

또한 플랫폼 독립적이어서 다양한 환경에서 같은 코드를 실행할 수 있습니다.

웹 개발, 데이터 분석, 스크립팅처럼 빠른 개발과 유연성이 중요하고 실행 속도가 크게 중요하지 않은 경우에는 Python, JavaScript 같은 인터프리터 언어가 더 적합합니다.

반면 시스템 프로그래밍, 게임 엔진, 임베디드 시스템처럼 최고 성능이 필요한 경우에는 C, C++, Rust 같은 컴파일 언어를 사용합니다.


**Q2. Java는 컴파일 언어인가요, 인터프리터 언어인가요?**

A. Java는 **둘 다 사용하는 하이브리드 방식**입니다.

1. 먼저 Java 소스코드(.java)를 **컴파일러(javac)**가 바이트코드(.class)로 컴파일합니다.
2. 이 바이트코드를 **JVM(Java Virtual Machine)**이 인터프리터 방식으로 실행합니다.
3. 추가로 JVM 내부의 **JIT(Just-In-Time) 컴파일러**가 자주 실행되는 코드를 기계어로 컴파일하여 성능을 높입니다.

이런 방식 덕분에 Java는 한 번 작성하면 JVM만 있으면 어디서든 실행할 수 있다는 장점이 있습니다.


**Q3. JIT(Just-In-Time) 컴파일러란 무엇인가요?**

A. JIT 컴파일러는 **실행 중에 자주 사용되는 코드를 기계어로 컴파일**하는 방식입니다. 인터프리터와 컴파일러의 장점을 결합한 것으로 볼 수 있습니다.

동작 방식:
1. 처음에는 인터프리터로 코드를 실행합니다.
2. 실행 중 자주 호출되는 핫스팟 코드를 감지합니다
3. 해당 부분을 기계어로 컴파일하여 캐싱합니다
4. 다음부터는 컴파일된 코드를 실행합니다

JavaScript의 V8 엔진, Java의 JVM, Python의 PyPy 등이 JIT 컴파일을 사용합니다. 덕분에 인터프리터 언어도 최근에는 상당히 빠른 성능을 낼 수 있게 되었습니다.

---

## 2. Git에서 Merge와 Rebase는 어떤 차이가 있나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.04)

**답변**

Merge와 Rebase는 둘 다 **브랜치를 통합하는 방법**이지만, 커밋 히스토리를 다루는 방식이 다릅니다.

Merge는 두 브랜치를 합칠 때 새로운 merge commit을 생성합니다. 예를 들어 feature 브랜치를 main에 merge하면, 두 브랜치의 변경사항이 합쳐지면서 "Merge branch 'feature' into main"이라는 새로운 커밋이 만들어집니다. 이 방식은 브랜치의 실제 작업 흐름을 그대로 보존합니다.

**Rebase**는 한 브랜치의 커밋들을 다른 브랜치의 **최신 커밋 위에 재배치**합니다. feature 브랜치를 main에 rebase하면, feature의 커밋들이 main의 최신 커밋 뒤에 순차적으로 붙어서 마치 처음부터 main에서 작업한 것처럼 **일직선의 히스토리**가 만들어집니다. merge commit이 생성되지 않습니다.

- Merge: 협업 시 안전하고, 브랜치 작업 흐름을 명확히 보존하고 싶을 때. 공개된 커밋을 통합할 때
- Rebase: 깔끔한 히스토리를 원할 때, 아직 push하지 않은 로컬 작업을 정리할 때


## **예상 꼬리질문**

**Q1. Rebase를 사용할 때 주의해야 할 점은 무엇인가요?**

A. 가장 중요한 원칙은 이미 공개, push된 커밋은 rebase하지 않는 것입니다. 

Rebase는 커밋의 해시값을 변경하기 때문에, 이미 다른 사람이 pull한 커밋을 rebase하면 같은 변경사항이지만 다른 해시를 가진 커밋이 생깁니다. 이렇게 되면 다른 팀원들이 pull할 때 충돌이 발생하고, 히스토리가 꼬여버리는 문제가 생깁니다.

따라서 rebase는 아직 push하지 않은 로컬 커밋을 정리할 때만 사용하는 것이 안전합니다. 이미 공유된 브랜치에서는 merge를 사용하는 것이 좋습니다.

**Q2. Merge conflict는 왜 발생하고, 어떻게 해결하나요?**

A. Merge conflict는 같은 파일의 같은 부분을 서로 다른 브랜치에서 다르게 수정했을 때 발생합니다. Git이 자동으로 어떤 변경을 선택해야 할지 판단할 수 없기 때문입니다.

---

## 3. CI/CD란 무엇이고, 왜 필요한가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.19)

**답변**

CI/CD는 **Continuous Integration(지속적 통합)**과 **Continuous Delivery/Deployment(지속적 전달/배포)**의 약자로, 코드 변경부터 배포까지의 과정을 자동화하는 개발 방법론입니다.

**CI (Continuous Integration, 지속적 통합)**

개발자가 코드를 변경하고 원격 저장소에 Push할 때마다, **자동으로 빌드하고 테스트**를 실행하는 것입니다.
예를 들어 GitHub에 코드를 올리면 자동으로 테스트가 돌아가서 "이 코드 문제없어요" 또는 "테스트 실패했어요"라고 즉시 알려줍니다.

**CD (Continuous Delivery, 지속적 배포)**

테스트를 통과한 코드를 **자동으로 배포 가능한 상태로 만들거나(Delivery), 실제 서버에 자동으로 배포(Deployment)**하는 것입니다.
- Continuous Delivery: 배포 준비까지 자동, 실제 배포는 수동 승인
- Continuous Deployment: 배포까지 완전 자동

**왜 필요한가요?**

**1. 빠른 피드백**
코드에 문제가 있으면 몇 분 안에 알 수 있어서, 며칠 후에 문제를 발견하는 것보다 훨씬 빠르게 수정할 수 있습니다.

**2. 휴먼 에러 방지**
수동 배포 시 "이 파일 빠뜨렸네", "설정 파일 안 바꿨네" 같은 실수가 생기는데, 자동화하면 항상 동일한 절차로 배포됩니다.

**3. 잦은 배포 가능**
수동 배포는 시간과 위험 부담 때문에 한 달에 한 번씩 큰 업데이트를 하게 되지만, CI/CD를 사용하면 하루에도 여러 번 작은 변경사항을 안전하게 배포할 수 있습니다.

**4. 팀 협업 개선**
여러 개발자가 동시에 작업해도, 각자의 코드가 자동으로 통합되고 테스트되어 충돌을 빠르게 발견할 수 있습니다.

**CI/CD 파이프라인 흐름**

```
코드 Push → 빌드 → 테스트 → 배포 → 모니터링
```

**1. 빌드 단계**
소스 코드를 컴파일하고, 필요한 라이브러리를 다운로드하며, 애플리케이션을 패키징합니다.

**2. 테스트 단계**
유닛 테스트, 통합 테스트, 기능 테스트 등을 실행하여 코드의 품질을 검증합니다. 테스트가 실패하면 파이프라인이 중단되고 개발자에게 알림이 갑니다.

**3. 배포 단계**
테스트를 통과한 코드를 스테이징 환경이나 프로덕션 환경에 배포합니다. Docker 이미지를 생성하고 Kubernetes 클러스터에 배포하는 등의 작업이 포함됩니다.

**4. 모니터링 및 피드백 단계**
배포된 애플리케이션의 성능과 안정성을 모니터링하고, 문제가 발생하면 빠르게 롤백하거나 수정합니다.

대표적인 CI/CD 도구로는 GitHub Actions, Jenkins, GitLab CI, CircleCI 등이 있습니다.


## **예상 꼬리질문**

**Q1. CI/CD 없이 수동으로 배포하면 어떤 문제가 있나요?**

A. 수동 배포의 가장 큰 문제는 **반복 가능성과 일관성 부족**입니다.

**실제 시나리오:**
1. 개발자 A가 금요일 저녁에 배포하려고 서버에 접속합니다
2. "음... 어떤 파일을 업로드해야 하지?"
3. 20개 파일 중 1개를 빠뜨림
4. 서버 재시작 명령어를 잘못 입력
5. 사이트가 다운되고, 주말 내내 긴급 대응

**수동 배포의 문제점:**
- 사람마다 배포 방식이 다름 (문서화되어 있어도 놓치는 단계 발생)
- 시간이 오래 걸림 (테스트→빌드→배포에 몇 시간)
- 배포가 두려워서 변경을 미루게 됨
- 특정 사람만 배포 방법을 알고 있어 의존성 발생

CI/CD를 사용하면 "Git에 Push만 하면 끝"이므로 이런 문제가 사라집니다.


**Q2. 테스트가 실패하면 CI/CD 파이프라인은 어떻게 되나요?**

A. 파이프라인이 **즉시 중단**되고 배포가 진행되지 않습니다.

**동작 방식:**
1. 개발자가 코드를 Push
2. CI 서버가 자동으로 테스트 실행
3. 테스트 중 하나라도 실패하면 파이프라인 중단
4. 개발자에게 알림 (이메일, Slack 등)
5. 코드를 수정하고 다시 Push
6. 모든 테스트 통과하면 배포 진행

**장점:**
- 버그가 있는 코드가 프로덕션에 절대 배포되지 않음
- 문제를 빨리 발견할수록 수정 비용이 적음
- 팀원들이 "누가 빌드를 깼어?"라고 바로 알 수 있음

예를 들어 GitHub Actions에서는 Pull Request에 빨간 X 표시가 나타나서 "이 코드는 머지하면 안 돼"라고 시각적으로 알려줍니다.

---

## 4. 가비지 컬렉션(Garbage Collection)이란 무엇이고, 어떻게 동작하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.20/2026.02.04)

**답변**

가비지 컬렉션은 프로그램이 더 이상 사용하지 않는 메모리를 자동으로 찾아서 해제해주는 기능입니다. Java나 Python 같은 언어에서는 개발자가 직접 메모리를 해제하지 않아도 GC가 알아서 처리해줍니다.

동작 방식은 대표적으로 Mark-and-Sweep 알고리즘이 있습니다.
먼저 Mark 단계에서 루트(지역 변수, 전역 변수 등)에서 시작해서 참조를 따라가며 사용중인 객체를 표시합니다.
그 다음 Sweep 단계에서 표시되지 않은 객체, 즉 더 이상 접근할 수 없는 객체를 메모리에서 제거합니다.

쉽게 말하면 "아직 누군가 쓰고 있다면 남기고, 아무도 쓰지 않으면 치운다"는 방식입니다.


## **예상 꼬리질문**

**Q1. GC가 있는 언어에서도 메모리 누수가 발생할 수 있나요?**

A. 네, 발생할 수 있습니다. GC는 참조가 없는 객체만 정리하니까, 불필요한데도 참조가 남아있으면 GC가 치우지 못합니다.
예를 들어 이벤트 리스너를 등록해놓고 해제를 안 하거나, static 컬렉션에 객체를 계속 추가만 하고 제거하지 않으면 메모리가 계속 쌓입니다. 그래서 GC가 있더라도 불필요한 참조를 정리해주는 습관이 중요합니다.

**Q2. GC의 장단점은 뭔가요?**

A. 장점은 개발자가 메모리 해제를 신경 안 써도 되니까 생산성이 높고, 이미 해제된 메모리에 접근하는 버그 같은 걸 방지할 수 있습니다.

단점은 GC가 실행될 때 프로그램이 잠깐 멈추거나 느려질 수 있고, 언제 실행될지 예측하기 어렵습니다. 
그래서 실시간 시스템이나 게임 엔진처럼 성능이 극한으로 중요한 곳에서는 C/C++처럼 수동으로 메모리를 관리하기도 합니다.

**Q3. Java의 GC는 어떻게 동작하나요?**
A. Java는 힙 메모리를 Young Generation과 Old Generation으로 나눠서 관리합니다. 
새로 생성된 객체는 Young 영역에 들어가고, 여기서 살아남은 객체가 Old 영역으로 이동합니다.

Young 영역에서 일어나는 Minor GC는 자주, 빠르게 실행되고, Old 영역에서 일어나는 Major GC는 드물지만 오래 걸립니다. 
대부분의 객체는 금방 사용되고 버려지기 때문에 이렇게 나눠서 효율적으로 관리하는 겁니다.

---

## 5. 이벤트 루프(Event Loop)란 무엇이고, 어떻게 동작하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.12.12)

**답변**

이벤트 루프는 **싱글 스레드 환경에서 비동기 작업을 처리하기 위한 메커니즘**입니다. 콜 스택이 비어있을 때 대기 중인 비동기 작업을 가져와 실행하는 무한 루프입니다.

**동작 순서**
1. **콜 스택(Call Stack)**: 실행 중인 함수가 쌓이는 곳. 함수 호출 시 push, 완료 시 pop
2. **Web API / 백그라운드**: 비동기 작업(setTimeout, HTTP 요청 등)이 처리되는 곳
3. **태스크 큐(Task Queue)**: 완료된 비동기 작업의 콜백이 대기하는 곳
4. **이벤트 루프**: 콜 스택이 비면 태스크 큐에서 콜백을 가져와 콜 스택에 넣음

이 구조 덕분에 싱글 스레드임에도 I/O 작업 중 블로킹 없이 다른 작업을 처리할 수 있습니다.


## **예상 꼬리질문**

**Q1. 마이크로태스크 큐와 태스크 큐의 차이는 무엇인가요?**

A. 둘 다 비동기 콜백이 대기하는 큐지만, **우선순위가 다릅니다**.

**마이크로태스크 큐 (우선순위 높음)**
- Promise.then, async/await, MutationObserver
- 콜 스택이 비면 태스크 큐보다 **먼저** 처리
- 마이크로태스크 큐가 빌 때까지 모두 실행

**태스크 큐 (매크로태스크 큐)**
- setTimeout, setInterval, I/O, UI 렌더링
- 마이크로태스크 큐가 빈 후에 하나씩 처리

```
console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'));
console.log('4');

// 출력: 1 → 4 → 3 → 2
```

동기 코드(1, 4) 먼저, 마이크로태스크(3) 그 다음, 태스크(2) 마지막입니다.


**Q2. Node.js의 이벤트 루프는 브라우저와 다른가요?**

A. 기본 개념은 같지만, Node.js는 **더 세분화된 페이즈(Phase)**를 가집니다.

1. **Timers**: setTimeout, setInterval 콜백
2. **Pending callbacks**: 시스템 콜백
3. **Poll**: I/O 콜백 처리, 새 I/O 이벤트 대기
4. **Check**: setImmediate 콜백
5. **Close callbacks**: close 이벤트 콜백

각 페이즈마다 해당하는 콜백을 처리하고, 페이즈 사이에 마이크로태스크(Promise, process.nextTick)를 처리합니다. `process.nextTick`은 Promise보다도 우선순위가 높습니다.

---

