## 📚 질문 목록
1. [컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점은 무엇인가요?](#1-컴파일러compiler와-인터프리터interpreter의-차이점은-무엇인가요-어떤-언어가-컴파일러를-쓰고-어떤-언어가-인터프리터를-쓰는지-예시를-들어봐도-좋습니다)
2. [Git에서 Merge와 Rebase는 어떤 차이가 있나요?](#2-git에서-merge와-rebase는-어떤-차이가-있나요)
3. [CI/CD란 무엇이고, 왜 필요한가요?](#3-cicd란-무엇이고-왜-필요한가요)
4. [가비지 컬렉션(Garbage Collection)이란 무엇이고, 어떻게 동작하나요?](#4-가비지-컬렉션garbage-collection이란-무엇이고-어떻게-동작하나요)

---

## 1. 컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점은 무엇인가요? 어떤 언어가 컴파일러를 쓰고, 어떤 언어가 인터프리터를 쓰는지 예시를 들어봐도 좋습니다.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.29)

**답변**

컴파일러와 인터프리터는 **소스 코드를 실행하는 두 가지 서로 다른 방식**입니다.

**컴파일러(Compiler)**는 우리가 작성한 소스 코드 전체를 **한 번에 기계어로 번역**하여 실행 파일을 만듭니다. 이후에는 이 실행 파일을 직접 실행하므로, 번역 과정 없이 바로 실행됩니다.

영어 책 전체를 한글로 번역해서 한글 책을 만든 다음, 그 책을 읽는 것과 같습니다.

**인터프리터(Interpreter)**는 소스 코드를 **한 줄씩 읽으면서 바로바로 실행**합니다. 매번 실행할 때마다 코드를 해석하는 과정이 필요합니다.

마치 영어를 읽으면서 한 문장씩 한국어로 번역하는 것과 같습니다.

**언어별 예시**

- **컴파일 언어**: C, C++, Java(중간), Rust, Swift
- **인터프리터 언어**: Python, JavaScript, PHP


## **예상 꼬리질문**

**Q1. 컴파일러 언어가 더 빠른데, 왜 인터프리터 언어를 사용하나요?**

A. 개발 생산성과 편의성 때문입니다. 인터프리터 언어는 코드를 수정한 후 바로 실행해볼 수 있어서 개발 속도가 빠르고, 디버깅이 쉽습니다. 

또한 플랫폼 독립적이어서 다양한 환경에서 같은 코드를 실행할 수 있습니다.

웹 개발, 데이터 분석, 스크립팅처럼 빠른 개발과 유연성이 중요하고 실행 속도가 크게 중요하지 않은 경우에는 Python, JavaScript 같은 인터프리터 언어가 더 적합합니다.

반면 시스템 프로그래밍, 게임 엔진, 임베디드 시스템처럼 최고 성능이 필요한 경우에는 C, C++, Rust 같은 컴파일 언어를 사용합니다.

**Q2. Java는 컴파일 언어인가요, 인터프리터 언어인가요?**

A. Java는 **둘 다 사용하는 하이브리드 방식**입니다.

1. 먼저 Java 소스코드(.java)를 **컴파일러(javac)**가 바이트코드(.class)로 컴파일합니다.
2. 이 바이트코드를 **JVM(Java Virtual Machine)**이 인터프리터 방식으로 실행합니다.
3. 추가로 JVM 내부의 **JIT(Just-In-Time) 컴파일러**가 자주 실행되는 코드를 기계어로 컴파일하여 성능을 높입니다.

이런 방식 덕분에 Java는 한 번 작성하면 JVM만 있으면 어디서든 실행할 수 있다는 장점이 있습니다.


**Q3. JIT(Just-In-Time) 컴파일러란 무엇인가요?**

A. JIT 컴파일러는 **실행 중에 자주 사용되는 코드를 기계어로 컴파일**하는 방식입니다. 인터프리터와 컴파일러의 장점을 결합한 것으로 볼 수 있습니다.

동작 방식:
1. 처음에는 인터프리터로 코드를 실행합니다.
2. 실행 중 자주 호출되는 핫스팟 코드를 감지합니다
3. 해당 부분을 기계어로 컴파일하여 캐싱합니다
4. 다음부터는 컴파일된 코드를 실행합니다

JavaScript의 V8 엔진, Java의 JVM, Python의 PyPy 등이 JIT 컴파일을 사용합니다. 덕분에 인터프리터 언어도 최근에는 상당히 빠른 성능을 낼 수 있게 되었습니다.

---

## 2. Git에서 Merge와 Rebase는 어떤 차이가 있나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.04)

**답변**

Merge와 Rebase는 둘 다 **브랜치를 통합하는 방법**이지만, 커밋 히스토리를 다루는 방식이 다릅니다.

Merge는 두 브랜치를 합칠 때 새로운 merge commit을 생성합니다. 예를 들어 feature 브랜치를 main에 merge하면, 두 브랜치의 변경사항이 합쳐지면서 "Merge branch 'feature' into main"이라는 새로운 커밋이 만들어집니다. 이 방식은 브랜치의 실제 작업 흐름을 그대로 보존합니다.

**Rebase**는 한 브랜치의 커밋들을 다른 브랜치의 **최신 커밋 위에 재배치**합니다. feature 브랜치를 main에 rebase하면, feature의 커밋들이 main의 최신 커밋 뒤에 순차적으로 붙어서 마치 처음부터 main에서 작업한 것처럼 **일직선의 히스토리**가 만들어집니다. merge commit이 생성되지 않습니다.

- Merge: 협업 시 안전하고, 브랜치 작업 흐름을 명확히 보존하고 싶을 때. 공개된 커밋을 통합할 때
- Rebase: 깔끔한 히스토리를 원할 때, 아직 push하지 않은 로컬 작업을 정리할 때


## **예상 꼬리질문**

**Q1. Rebase를 사용할 때 주의해야 할 점은 무엇인가요?**

A. 가장 중요한 원칙은 이미 공개, push된 커밋은 rebase하지 않는 것입니다. 

Rebase는 커밋의 해시값을 변경하기 때문에, 이미 다른 사람이 pull한 커밋을 rebase하면 같은 변경사항이지만 다른 해시를 가진 커밋이 생깁니다. 이렇게 되면 다른 팀원들이 pull할 때 충돌이 발생하고, 히스토리가 꼬여버리는 문제가 생깁니다.

따라서 rebase는 아직 push하지 않은 로컬 커밋을 정리할 때만 사용하는 것이 안전합니다. 이미 공유된 브랜치에서는 merge를 사용하는 것이 좋습니다.

**Q2. Merge conflict는 왜 발생하고, 어떻게 해결하나요?**

A. Merge conflict는 같은 파일의 같은 부분을 서로 다른 브랜치에서 다르게 수정했을 때 발생합니다. Git이 자동으로 어떤 변경을 선택해야 할지 판단할 수 없기 때문입니다.

---

## 3. CI/CD란 무엇이고, 왜 필요한가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.19)

**답변**

CI/CD는 **Continuous Integration(지속적 통합)**과 **Continuous Delivery/Deployment(지속적 전달/배포)**의 약자로, 코드 변경부터 배포까지의 과정을 자동화하는 개발 방법론입니다.

**CI (Continuous Integration, 지속적 통합)**

개발자가 코드를 변경하고 원격 저장소에 Push할 때마다, **자동으로 빌드하고 테스트**를 실행하는 것입니다.
예를 들어 GitHub에 코드를 올리면 자동으로 테스트가 돌아가서 "이 코드 문제없어요" 또는 "테스트 실패했어요"라고 즉시 알려줍니다.

**CD (Continuous Delivery, 지속적 배포)**

테스트를 통과한 코드를 **자동으로 배포 가능한 상태로 만들거나(Delivery), 실제 서버에 자동으로 배포(Deployment)**하는 것입니다.
- Continuous Delivery: 배포 준비까지 자동, 실제 배포는 수동 승인
- Continuous Deployment: 배포까지 완전 자동

**왜 필요한가요?**

**1. 빠른 피드백**
코드에 문제가 있으면 몇 분 안에 알 수 있어서, 며칠 후에 문제를 발견하는 것보다 훨씬 빠르게 수정할 수 있습니다.

**2. 휴먼 에러 방지**
수동 배포 시 "이 파일 빠뜨렸네", "설정 파일 안 바꿨네" 같은 실수가 생기는데, 자동화하면 항상 동일한 절차로 배포됩니다.

**3. 잦은 배포 가능**
수동 배포는 시간과 위험 부담 때문에 한 달에 한 번씩 큰 업데이트를 하게 되지만, CI/CD를 사용하면 하루에도 여러 번 작은 변경사항을 안전하게 배포할 수 있습니다.

**4. 팀 협업 개선**
여러 개발자가 동시에 작업해도, 각자의 코드가 자동으로 통합되고 테스트되어 충돌을 빠르게 발견할 수 있습니다.

**CI/CD 파이프라인 흐름**

```
코드 Push → 빌드 → 테스트 → 배포 → 모니터링
```

**1. 빌드 단계**
소스 코드를 컴파일하고, 필요한 라이브러리를 다운로드하며, 애플리케이션을 패키징합니다.

**2. 테스트 단계**
유닛 테스트, 통합 테스트, 기능 테스트 등을 실행하여 코드의 품질을 검증합니다. 테스트가 실패하면 파이프라인이 중단되고 개발자에게 알림이 갑니다.

**3. 배포 단계**
테스트를 통과한 코드를 스테이징 환경이나 프로덕션 환경에 배포합니다. Docker 이미지를 생성하고 Kubernetes 클러스터에 배포하는 등의 작업이 포함됩니다.

**4. 모니터링 및 피드백 단계**
배포된 애플리케이션의 성능과 안정성을 모니터링하고, 문제가 발생하면 빠르게 롤백하거나 수정합니다.

대표적인 CI/CD 도구로는 GitHub Actions, Jenkins, GitLab CI, CircleCI 등이 있습니다.


## **예상 꼬리질문**

**Q1. CI/CD 없이 수동으로 배포하면 어떤 문제가 있나요?**

A. 수동 배포의 가장 큰 문제는 **반복 가능성과 일관성 부족**입니다.

**실제 시나리오:**
1. 개발자 A가 금요일 저녁에 배포하려고 서버에 접속합니다
2. "음... 어떤 파일을 업로드해야 하지?"
3. 20개 파일 중 1개를 빠뜨림
4. 서버 재시작 명령어를 잘못 입력
5. 사이트가 다운되고, 주말 내내 긴급 대응

**수동 배포의 문제점:**
- 사람마다 배포 방식이 다름 (문서화되어 있어도 놓치는 단계 발생)
- 시간이 오래 걸림 (테스트→빌드→배포에 몇 시간)
- 배포가 두려워서 변경을 미루게 됨
- 특정 사람만 배포 방법을 알고 있어 의존성 발생

CI/CD를 사용하면 "Git에 Push만 하면 끝"이므로 이런 문제가 사라집니다.


**Q2. 테스트가 실패하면 CI/CD 파이프라인은 어떻게 되나요?**

A. 파이프라인이 **즉시 중단**되고 배포가 진행되지 않습니다.

**동작 방식:**
1. 개발자가 코드를 Push
2. CI 서버가 자동으로 테스트 실행
3. 테스트 중 하나라도 실패하면 파이프라인 중단
4. 개발자에게 알림 (이메일, Slack 등)
5. 코드를 수정하고 다시 Push
6. 모든 테스트 통과하면 배포 진행

**장점:**
- 버그가 있는 코드가 프로덕션에 절대 배포되지 않음
- 문제를 빨리 발견할수록 수정 비용이 적음
- 팀원들이 "누가 빌드를 깼어?"라고 바로 알 수 있음

예를 들어 GitHub Actions에서는 Pull Request에 빨간 X 표시가 나타나서 "이 코드는 머지하면 안 돼"라고 시각적으로 알려줍니다.

---

## 4. 가비지 컬렉션(Garbage Collection)이란 무엇이고, 어떻게 동작하나요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.11.20)

**답변**

가비지 컬렉션(GC)은 프로그램이 사용하지 않는 메모리를 **자동으로 찾아서 해제**해주는 메모리 관리 기법입니다. 개발자가 직접 메모리를 할당하고 해제할 필요 없이, 런타임이 더 이상 참조되지 않는 객체를 자동으로 정리해줍니다.

**동작 방식 (Mark-and-Sweep 알고리즘 기준)**

1. **Mark (표시 단계)**: GC가 실행되면 현재 사용 중인 객체를 찾기 위해 루트(에서 시작해서 참조를 따라가며 접근 가능한 모든 객체에 "살아있음" 표시를 합니다. 루트는 스택의 지역 변수, 전역 변수, CPU 레지스터 등을 의미합니다.

2. **Sweep (정리 단계)**: 표시되지 않은 객체들(= 더 이상 접근할 수 없는 객체들)을 메모리에서 제거하고 해당 공간을 재사용 가능하게 만듭니다.

Java, Python, JavaScript, C#, Go 같은 언어들이 GC를 지원하며, C/C++처럼 수동으로 메모리를 관리하는 언어와 대비됩니다.


## **예상 꼬리질문**

**Q1. 가비지 컬렉션을 사용하는 언어에서도 메모리 누수가 발생할 수 있나요?**

A. 네, 발생할 수 있습니다. GC는 참조되지 않는 객체만 정리하기 때문에, 불필요한데도 계속 참조가 남아있으면 메모리 누수가 발생합니다.

예를 들어:
- **이벤트 리스너 미해제**: 이벤트 리스너를 등록했는데 제거하지 않으면, 리스너가 참조하는 객체들이 계속 메모리에 남아있습니다.
- **전역 변수나 static 컬렉션**: 계속 객체를 추가만 하고 제거하지 않으면 메모리가 계속 쌓입니다.
- **클로저가 외부 변수를 캡처**: 함수가 종료된 후에도 클로저가 큰 객체를 계속 참조하고 있으면 해당 객체가 해제되지 않습니다.

따라서 GC 언어에서도 불필요한 참조를 명시적으로 제거해주는 것이 중요합니다.

**Q3. C/C++처럼 수동으로 메모리를 관리하는 언어와 비교했을 때, GC의 장단점은 무엇인가요?**

A. **GC의 장점**
- **메모리 관리 실수 방지**: 개발자가 메모리 해제를 깜빡해서 생기는 메모리 누수나, 이미 해제된 메모리에 접근하는 Use-After-Free 버그를 방지할 수 있습니다.
- **생산성 향상**: 메모리 관리를 신경 쓰지 않아도 되니 비즈니스 로직 개발에 집중할 수 있습니다.

**GC의 단점**
- **성능 오버헤드**: GC가 실행되는 동안 프로그램이 멈추거나 느려질 수 있습니다.
- **예측 불가능한 타이밍**: GC가 언제 실행될지 정확히 예측하기 어렵습니다.
- **메모리 사용량 증가**: GC가 동작하려면 추가 메모리 공간이 필요하고, 즉시 해제되지 않고 다음 GC까지 기다려야 하므로 메모리 사용량이 더 높을 수 있습니다.

따라서 임베디드 시스템이나 게임 엔진의 성능 중요 부분처럼 메모리와 성능을 극한까지 최적화해야 하는 경우에는 여전히 수동 메모리 관리가 선호되기도 합니다.

---
