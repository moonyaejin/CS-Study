## 📚 질문 목록
1. [컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점은 무엇인가요?](#1-컴파일러compiler와-인터프리터interpreter의-차이점은-무엇인가요-어떤-언어가-컴파일러를-쓰고-어떤-언어가-인터프리터를-쓰는지-예시를-들어봐도-좋습니다)
2. [Git에서 Merge와 Rebase는 어떤 차이가 있나요?](#2-git에서-merge와-rebase는-어떤-차이가-있나요)
---

## 1. 컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점은 무엇인가요? 어떤 언어가 컴파일러를 쓰고, 어떤 언어가 인터프리터를 쓰는지 예시를 들어봐도 좋습니다.
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.29)

**답변**

컴파일러와 인터프리터는 **소스 코드를 실행하는 두 가지 서로 다른 방식**입니다.

**컴파일러(Compiler)**는 우리가 작성한 소스 코드 전체를 **한 번에 기계어로 번역**하여 실행 파일을 만듭니다. 이후에는 이 실행 파일을 직접 실행하므로, 번역 과정 없이 바로 실행됩니다.

영어 책 전체를 한글로 번역해서 한글 책을 만든 다음, 그 책을 읽는 것과 같습니다.

**인터프리터(Interpreter)**는 소스 코드를 **한 줄씩 읽으면서 바로바로 실행**합니다. 매번 실행할 때마다 코드를 해석하는 과정이 필요합니다.

마치 영어를 읽으면서 한 문장씩 한국어로 번역하는 것과 같습니다.

**언어별 예시**

- **컴파일 언어**: C, C++, Java(중간), Rust, Swift
- **인터프리터 언어**: Python, JavaScript, PHP


## **예상 꼬리질문**

**Q1. 컴파일러 언어가 더 빠른데, 왜 인터프리터 언어를 사용하나요?**

A. 개발 생산성과 편의성 때문입니다. 인터프리터 언어는 코드를 수정한 후 바로 실행해볼 수 있어서 개발 속도가 빠르고, 디버깅이 쉽습니다. 

또한 플랫폼 독립적이어서 다양한 환경에서 같은 코드를 실행할 수 있습니다.

웹 개발, 데이터 분석, 스크립팅처럼 빠른 개발과 유연성이 중요하고 실행 속도가 크게 중요하지 않은 경우에는 Python, JavaScript 같은 인터프리터 언어가 더 적합합니다.

반면 시스템 프로그래밍, 게임 엔진, 임베디드 시스템처럼 최고 성능이 필요한 경우에는 C, C++, Rust 같은 컴파일 언어를 사용합니다.

**Q2. Java는 컴파일 언어인가요, 인터프리터 언어인가요?**

A. Java는 **둘 다 사용하는 하이브리드 방식**입니다.

1. 먼저 Java 소스코드(.java)를 **컴파일러(javac)**가 바이트코드(.class)로 컴파일합니다.
2. 이 바이트코드를 **JVM(Java Virtual Machine)**이 인터프리터 방식으로 실행합니다.
3. 추가로 JVM 내부의 **JIT(Just-In-Time) 컴파일러**가 자주 실행되는 코드를 기계어로 컴파일하여 성능을 높입니다.

이런 방식 덕분에 Java는 한 번 작성하면 JVM만 있으면 어디서든 실행할 수 있다는 장점이 있습니다.


**Q3. JIT(Just-In-Time) 컴파일러란 무엇인가요?**

A. JIT 컴파일러는 **실행 중에 자주 사용되는 코드를 기계어로 컴파일**하는 방식입니다. 인터프리터와 컴파일러의 장점을 결합한 것으로 볼 수 있습니다.

동작 방식:
1. 처음에는 인터프리터로 코드를 실행합니다.
2. 실행 중 자주 호출되는 핫스팟 코드를 감지합니다
3. 해당 부분을 기계어로 컴파일하여 캐싱합니다
4. 다음부터는 컴파일된 코드를 실행합니다

JavaScript의 V8 엔진, Java의 JVM, Python의 PyPy 등이 JIT 컴파일을 사용합니다. 덕분에 인터프리터 언어도 최근에는 상당히 빠른 성능을 낼 수 있게 되었습니다.

---

## 2. Git에서 Merge와 Rebase는 어떤 차이가 있나요?
> 출처: 사용자 질문 (2025.11.04)

**답변**

Merge와 Rebase는 둘 다 **브랜치를 통합하는 방법**이지만, 커밋 히스토리를 다루는 방식이 다릅니다.

Merge는 두 브랜치를 합칠 때 새로운 merge commit을 생성합니다. 예를 들어 feature 브랜치를 main에 merge하면, 두 브랜치의 변경사항이 합쳐지면서 "Merge branch 'feature' into main"이라는 새로운 커밋이 만들어집니다. 이 방식은 브랜치의 실제 작업 흐름을 그대로 보존합니다.

**Rebase**는 한 브랜치의 커밋들을 다른 브랜치의 **최신 커밋 위에 재배치**합니다. feature 브랜치를 main에 rebase하면, feature의 커밋들이 main의 최신 커밋 뒤에 순차적으로 붙어서 마치 처음부터 main에서 작업한 것처럼 **일직선의 히스토리**가 만들어집니다. merge commit이 생성되지 않습니다.

- Merge: 협업 시 안전하고, 브랜치 작업 흐름을 명확히 보존하고 싶을 때. 공개된 커밋을 통합할 때
- Rebase: 깔끔한 히스토리를 원할 때, 아직 push하지 않은 로컬 작업을 정리할 때


## **예상 꼬리질문**

**Q1. Rebase를 사용할 때 주의해야 할 점은 무엇인가요?**

A. 가장 중요한 원칙은 이미 공개, push된 커밋은 rebase하지 않는 것입니다. 

Rebase는 커밋의 해시값을 변경하기 때문에, 이미 다른 사람이 pull한 커밋을 rebase하면 같은 변경사항이지만 다른 해시를 가진 커밋이 생깁니다. 이렇게 되면 다른 팀원들이 pull할 때 충돌이 발생하고, 히스토리가 꼬여버리는 문제가 생깁니다.

따라서 rebase는 아직 push하지 않은 로컬 커밋을 정리할 때만 사용하는 것이 안전합니다. 이미 공유된 브랜치에서는 merge를 사용하는 것이 좋습니다.

**Q2. Merge conflict는 왜 발생하고, 어떻게 해결하나요?**

A. Merge conflict는 같은 파일의 같은 부분을 서로 다른 브랜치에서 다르게 수정했을 때 발생합니다. Git이 자동으로 어떤 변경을 선택해야 할지 판단할 수 없기 때문입니다.

---
