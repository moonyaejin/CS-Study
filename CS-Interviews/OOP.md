## 📚 질문 목록

1. [객체 지향 프로그래밍(OOP)의 4가지 특징은 무엇인가요?](#1-객체-지향-프로그래밍oop의-4가지-특징은-무엇인가요)
2. [오버로딩(Overloading)과 오버라이딩(Overriding)의 차이점은 무엇인가요?](#2-오버로딩overloading과-오버라이딩overriding의-차이점은-무엇인가요)
3. [SOLID 원칙이란 무엇인가요?](#3-solid-원칙이란-무엇인가요)

## 1. 객체 지향 프로그래밍(OOP)의 4가지 특징은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.17)

**답변**

객체 지향 프로그래밍의 4가지 특징은 **캡슐화, 상속, 다형성, 추상화**입니다.

캡슐화는 데이터와 그 데이터를 다루는 메서드를 하나로 묶고, 외부에서 직접 접근하지 못하도록 보호하는 것입니다.
private 필드와 public getter/setter가 대표적인 예입니다.

상속은 기존 클래스의 속성과 메서드를 물려받아 새로운 클래스를 만드는 것입니다. 코드 재사용성을 높이고 계층 구조를 표현할 수 있습니다.

다형성은 같은 이름의 메서드가 상황에 따라 다르게 동작하는 것입니다. 같은 이름에 매개변수가 다른 오버로딩과, 상속받아 메서드를 재정의하는 오버라이딩이 있습니다.

추상화는 복잡한 세부 구현은 숨기고 공통된 특성만 뽑아서 일반화하는 것입니다. 인터페이스나 추상 클래스를 통해 "무엇을 할 수 있는가"만 정의하고, 구체적인 구현은 하위 클래스에 맡깁니다.

## **예상 꼬리질문**

**Q1. 캡슐화와 추상화의 차이점은 무엇인가요?**

A. 둘 다 "숨긴다"는 개념이 있지만 목적이 다릅니다.

캡슐화는 데이터 보호에 초점을 둡니다. 데이터를 외부로부터 숨기고, 허용된 방법으로만 접근하게 해서 데이터의 무결성을 지키는 것이 목적입니다. 예를 들면 은행 계좌에서 잔액을 마음대로 수정하지 못하게 막는 것이죠.

반면 추상화는 복잡도 감소에 초점을 둡니다. 복잡한 내부 동작 방식은 감추고, 사용자에게 필요한 인터페이스만 제공해서 사용을 쉽게 만드는 것이 목적입니다.

---

## 2. 오버로딩(Overloading)과 오버라이딩(Overriding)의 차이점은 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.20)

**답변**

오버로딩은 같은 클래스 내에서 같은 이름의 메서드를 매개변수의 타입, 개수, 순서를 다르게 해서 여러 개 정의하는 것입니다. 예를 들어 `add(int a, int b)`와 `add(int a, int b, int c)`처럼 매개변수 개수를 다르게 해서 상황에 맞는 메서드를 선택할 수 있습니다. 컴파일 타임에 어떤 메서드를 호출할지 결정되며, 같은 클래스 내에서 이루어집니다.

오버라이딩은 상속 관계에서 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것입니다. 런타임에 실제 객체의 타입에 따라 어떤 메서드를 호출할지 결정되며(동적 바인딩), 메서드의 시그니처(이름, 매개변수)가 완전히 동일해야 합니다.

- 오버로딩: 같은 클래스 내, 매개변수가 다름, 컴파일 타임 다형성
- 오버라이딩: 상속 관계, 메서드 시그니처 동일, 런타임 다형성

## **예상 꼬리질문**
**Q1. 오버로딩에서 반환 타입만 다르게 하면 메서드를 구별할 수 있나요?**

A. 아니요, 반환 타입만 다르게 해서는 오버로딩이 성립하지 않습니다.
메서드를 호출할 때 컴파일러는 메서드 이름과 매개변수 정보만으로 어떤 메서드를 호출할지 결정합니다. 반환 타입은 메서드 호출 시점에는 고려되지 않기 때문에, 반환 타입만 다르면 컴파일러가 둘을 구별할 수 없어 컴파일 에러가 발생합니다.
예를 들어 int calculate(int a)와 double calculate(int a)는 오버로딩이 불가능합니다.

**Q2. 오버라이딩 시 접근 제어자는 어떻게 설정해야 하나요?**

A. 오버라이딩할 때 접근 제어자는 부모 클래스의 메서드보다 더 넓은 범위로만 설정할 수 있습니다.
예를 들어 부모 클래스의 메서드가 protected라면, 자식 클래스에서는 protected 또는 public으로 오버라이딩할 수 있지만, private이나 default로는 좁힐 수 없습니다.
이는 리스코프 치환 원칙(LSP)과 관련이 있는데, 자식 클래스 객체가 부모 클래스 타입으로 사용될 때 부모 클래스에서 접근 가능했던 메서드는 자식 클래스에서도 동일하게 접근 가능해야 하기 때문입니다. 접근 범위를 좁히면 이 원칙이 위배됩니다.

- 제어자의 범위 : public > protected > default > private

**Q3. Java에서 static 메서드는 오버라이딩이 가능한가요?**

A. 아니요, static 메서드는 오버라이딩할 수 없습니다.
static 메서드는 클래스에 속하며 컴파일 타임에 정적 바인딩됩니다. 반면 오버라이딩은 런타임에 실제 객체의 타입을 보고 동적으로 바인딩하는 메커니즘입니다.
자식 클래스에서 부모 클래스의 static 메서드와 동일한 시그니처의 static 메서드를 만들 수는 있지만, 이는 오버라이딩이 아니라 메서드 은닉(method hiding)이라고 합니다. 이 경우 참조 변수의 타입에 따라 어떤 메서드가 호출될지 결정되지, 실제 객체의 타입과는 무관합니다.

---
## 3. SOLID 원칙이란 무엇인가요?
> 출처: 개발자: 데일리 CS 역량 강화 챌린지 (2025.10.23)

**답변**

SOLID 원칙은 객체지향 설계에서 **유지보수가 쉽고 확장 가능한 소프트웨어**를 만들기 위한 5가지 설계 원칙입니다.

**S - SRP (Single Responsibility Principle, 단일 책임 원칙)**
- 하나의 클래스는 하나의 책임만 가져야 합니다
- 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 합니다

**O - OCP (Open/Closed Principle, 개방-폐쇄 원칙)**
- 확장에는 열려있고, 수정에는 닫혀있어야 합니다
- 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있어야 합니다

**L - LSP (Liskov Substitution Principle, 리스코프 치환 원칙)**
- 자식 클래스는 부모 클래스를 대체할 수 있어야 합니다
- 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 합니다

**I - ISP (Interface Segregation Principle, 인터페이스 분리 원칙)**
- 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 합니다

**D - DIP (Dependency Inversion Principle, 의존성 역전 원칙)**
- 고수준 모듈은 저수준 모듈에 의존하면 안 되고, 둘 다 추상화에 의존해야 합니다
- 구체적인 구현체가 아닌 추상화(인터페이스)에 의존해야 합니다
