# 슬라이딩 윈도우 (Sliding Window)

## 📌 핵심 개념

슬라이딩 윈도우는 **배열이나 문자열에서 연속된 부분 구간을 효율적으로 처리하기 위한 알고리즘 기법**입니다.

**핵심 아이디어**: 
- 일정한 크기(고정) 또는 조건에 따른 크기(가변)의 '윈도우(구간)'를 만듭니다
- 이 윈도우를 배열 위에서 **한 칸씩 이동**시키며 결과를 계산합니다
- 매번 전체를 다시 계산하지 않고, **이전 결과를 재활용**합니다
  - 윈도우가 오른쪽으로 이동할 때: 왼쪽 끝 원소를 제거하고, 오른쪽에 새 원소를 추가

**실생활 비유**:
기차를 타고 가면서 창밖 풍경을 봅니다. 창문(윈도우)의 크기는 고정되어 있고, 기차가 움직이면서 보이는 풍경이 바뀝니다. 이전 풍경의 정보를 활용하면서 새로운 풍경을 관찰하는 것과 같습니다.

---

## 🔍 왜 필요한가?

### 문제 상황
배열 `[2, 1, 5, 1, 3, 2]`에서 **크기 3인 부분 배열의 최대 합**을 구해야 한다고 가정해봅시다.

### 방법 1: 완전탐색 (Brute Force)
```python
# 모든 크기 3 부분 배열을 매번 처음부터 계산
[2, 1, 5] → 2 + 1 + 5 = 8
[1, 5, 1] → 1 + 5 + 1 = 7
[5, 1, 3] → 5 + 1 + 3 = 9
[1, 3, 2] → 1 + 3 + 2 = 6
```
- **시간복잡도**: O(n × k) - 각 위치마다 k개 원소를 더함
- n이 크면 비효율적!

### 방법 2: 슬라이딩 윈도우
> 새로운 윈도우 합 = 이전 합 - 빠져나간 값 + 들어온 값
```python
# 첫 윈도우만 처음부터 계산
[2, 1, 5] → 2 + 1 + 5 = 8

# 이후엔 변화만 반영
[1, 5, 1] → 8 - 2 + 1 = 7  (2를 빼고 1을 더함)
[5, 1, 3] → 7 - 1 + 3 = 9  (1을 빼고 3을 더함)
[1, 3, 2] → 9 - 5 + 2 = 6  (5를 빼고 2를 더함)
```
- **시간복잡도**: O(n) - 한 번의 순회만 필요
- 훨씬 효율적! ✨

---

## 📊 시간복잡도 분석

| 방법 | 시간복잡도 | 공간복잡도 |
|------|-----------|-----------|
| 완전탐색 (이중 반복문) | O(n × k) | O(1) |
| 슬라이딩 윈도우 | O(n) | O(1) |

**예시**: 배열 크기 n=100,000, 윈도우 크기 k=1,000
- 완전탐색: 100,000 × 1,000 = 100,000,000 연산
- 슬라이딩 윈도우: 100,000 연산
- **약 1,000배 차이!**

---

## 🎯 언제 사용하는가?

슬라이딩 윈도우를 사용할 수 있는 문제의 특징:

### 1. **연속성 (Contiguous)**
- 반드시 **연속된 부분 배열/문자열**을 다뤄야 함
- ✅ "연속된 k개 원소의 합"
- ❌ "임의의 k개 원소의 합" (연속성 X)

### 2. **구간 관련 최적화 문제**
- 최대값, 최소값, 합계, 평균 등을 구하는 문제
- ✅ "최대 합을 가진 부분 배열"
- ✅ "조건을 만족하는 최소 길이 부분 배열"

---

## 🔄 두 가지 유형

### 유형 1: 고정 크기 윈도우 (Fixed-size Window)

**특징**:
- 윈도우의 크기(길이)가 **문제에서 주어짐**
- 포인터 1개만 있어도 되지만, 명확성을 위해 2개 사용 가능
- 구현이 단순함

**예시 문제**:
- "크기 k인 부분 배열의 최대 합"
- "크기 3인 윈도우에서 각 원소의 평균 구하기"

**핵심 로직**:
1. 처음 k개 원소로 첫 윈도우 생성
2. 윈도우를 한 칸씩 오른쪽으로 이동
3. 매 이동마다: 왼쪽 끝 원소 제거 + 오른쪽 새 원소 추가

---

### 유형 2: 가변 크기 윈도우 (Variable-size Window)

**특징**:
- 윈도우의 크기가 **조건에 따라 동적으로 변함**
- 반드시 **두 개의 포인터** 필요 (left, right)
- 조건을 만족하도록 윈도우를 확장하거나 축소

**예시 문제**:
- "합이 S 이상인 가장 짧은 부분 배열"
- "중복 문자가 없는 가장 긴 부분 문자열"
- "특정 조건을 만족하는 부분 배열의 개수"

**핵심 로직**:
1. right 포인터로 윈도우를 확장 (원소 추가)
2. 조건이 만족되면 결과 갱신
3. 조건을 유지하면서 left 포인터로 윈도우 축소 (원소 제거)
4. right가 끝까지 도달할 때까지 반복

---

## 🎨 구현 패턴 (템플릿)

### 고정 크기 윈도우 템플릿

```java
public class SlidingWindow {
    
    public Integer slidingWindowFixed(int[] arr, int k) {
        if (arr.length < k) {
            return null;  // 예외 처리
        }
        
        // 1. 첫 윈도우 초기화
        int windowValue = 초기값_계산(arr, 0, k);
        int result = windowValue;
        
        // 2. 윈도우 이동
        for (int i = k; i < arr.length; i++) {
            // 왼쪽 원소 제거
            windowValue -= arr[i - k];
            // 오른쪽 원소 추가
            windowValue += arr[i];
            // 결과 갱신
            result = 결과_업데이트(result, windowValue);
        }
        
        return result;
    }
}
```

### 가변 크기 윈도우 템플릿

```java
public class SlidingWindow {
    
    public int slidingWindowVariable(int[] arr) {
        int left = 0;
        WindowState windowState = new WindowState();  // 초기_상태
        int result = 초기_결과;
        
        for (int right = 0; right < arr.length; right++) {
            // 1. 오른쪽 확장 (원소 추가)
            windowState = 윈도우에_추가(windowState, arr[right]);
            
            // 2. 조건 위반 시 왼쪽 축소
            while (조건_위반(windowState)) {
                windowState = 윈도우에서_제거(windowState, arr[left]);
                left++;
            }
            
            // 3. 결과 갱신
            result = 결과_업데이트(result, right - left + 1);
        }
        
        return result;
    }
}
```

---

## 💡 핵심 개념 정리

### 1. 윈도우 이동의 원리
```
처음: [a, b, c] | d, e, f
              
이후:  a, [b, c, d] | e, f

변화: -a (제거) +d (추가)
```

### 2. 포인터 관리
- **고정 크기**: `i` 하나만 사용 (또는 `i-k`와 `i`)
- **가변 크기**: `left`, `right` 두 개 사용
  - `right`: 항상 증가 (for 문)
  - `left`: 조건에 따라 증가 (while 문)

### 3. 윈도우 크기 계산
```python
window_size = right - left + 1
```
- left=0, right=2 → 크기 3 ([0], [1], [2])
- left=1, right=3 → 크기 3 ([1], [2], [3])

### 4. 상태 유지
윈도우 내부의 정보를 효율적으로 관리:
- **합계**: 변수 하나로 관리 (`window_sum`)
- **빈도수**: 해시맵 사용 (`Counter`, `dict`)
- **최대/최소**: 덱(deque) 또는 힙(heap) 사용

---

## 🆚 투 포인터와의 차이점

| 비교 항목 | 슬라이딩 윈도우 | 투 포인터 |
|----------|---------------|----------|
| **대상** | **연속된** 부분 배열/문자열 필수 | 배열 전체, 연속성 불필요 |
| **이동 방식** | 윈도우가 함께 이동 (오른쪽으로) | 각 포인터가 독립적으로 이동 |
| **방향** | 보통 한 방향 (→) | 양방향 가능 (← →) |
| **예시** | 최대 합 부분 배열 (연속) | 정렬된 배열에서 두 수의 합 |
